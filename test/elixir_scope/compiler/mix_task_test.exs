defmodule ElixirScope.Compiler.MixTaskTest do
  use ExUnit.Case
  import ExUnit.CaptureIO
  alias ElixirScope.Compiler.MixTask

  @test_project_path "test/fixtures/sample_project"
  @instrumented_output_path "test/fixtures/instrumented_output"

  describe "Mix compiler integration" do
    test "registers as a Mix compiler" do
      compilers = Mix.compilers()
      assert :elixir_scope in compilers
    end

    test "runs before elixir compiler" do
      # Verify elixir_scope runs before :elixir in the compiler chain
      position_elixir_scope = Enum.find_index(Mix.compilers(), &(&1 == :elixir_scope))
      position_elixir = Enum.find_index(Mix.compilers(), &(&1 == :elixir))

      assert position_elixir_scope < position_elixir
    end

    test "compiles project without errors" do
      assert {output, 0} = System.cmd("mix", ["compile"], cd: @test_project_path)
      assert output =~ "ElixirScope: Instrumented"
    end

    test "preserves original module behavior" do
      # Compile test module
      compile_test_module()

      # Test that original functionality is preserved
      assert TestModule.add(2, 3) == 5
      assert TestModule.multiply(4, 5) == 20
    end

    test "injects instrumentation calls" do
      # Compile and inspect generated bytecode
      {module, bytecode} = compile_and_get_bytecode(TestModule)

      # Verify instrumentation calls are present
      assert bytecode_contains_call?(bytecode, ElixirScope.Capture.InstrumentationRuntime, :report_function_entry)
      assert bytecode_contains_call?(bytecode, ElixirScope.Capture.InstrumentationRuntime, :report_function_exit)
    end
  end

  describe "AST transformation accuracy" do
    test "handles simple function definitions" do
      original_ast = quote do
        def simple_function(x) do
          x + 1
        end
      end

      transformed_ast = MixTask.transform_ast(original_ast, basic_plan())

      # Verify structure: entry call, original body, exit call
      assert match_instrumented_function_pattern?(transformed_ast)
    end

    test "handles functions with guards" do
      original_ast = quote do
        def guarded_function(x) when is_integer(x) do
          x * 2
        end
      end

      transformed_ast = MixTask.transform_ast(original_ast, basic_plan())

      # Verify guards are preserved
      assert guards_preserved?(transformed_ast)
      assert instrumentation_calls_present?(transformed_ast)
    end

    test "handles multiple function clauses" do
      original_ast = quote do
        def pattern_match(0), do: :zero
        def pattern_match(n) when n > 0, do: :positive
        def pattern_match(_), do: :negative
      end

      transformed_ast = MixTask.transform_ast(original_ast, basic_plan())

      # Each clause should be instrumented separately
      assert clause_count(transformed_ast) == 3
      assert all_clauses_instrumented?(transformed_ast)
    end

    test "handles GenServer callbacks" do
      original_ast = quote do
        def handle_call({:get, key}, _from, state) do
          value = Map.get(state, key)
          {:reply, value, state}
        end
      end

      plan = genserver_instrumentation_plan()
      transformed_ast = MixTask.transform_ast(original_ast, plan)

      # Should capture state before and after
      assert state_capture_calls_present?(transformed_ast)
    end

    test "preserves macro-generated code" do
      # Test with real Phoenix controller action
      original_ast = quote do
        def index(conn, _params) do
          users = Repo.all(User)
          render(conn, "index.html", users: users)
        end
      end

      transformed_ast = MixTask.transform_ast(original_ast, phoenix_plan())

      # Verify Phoenix-specific behavior is preserved
      assert phoenix_patterns_preserved?(transformed_ast)
    end
  end
end
