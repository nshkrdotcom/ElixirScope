# **Comprehensive Analysis of Observability, Debugging, and Tracing Tools in the BEAM Ecosystem: A Comparative Study with ElixirScope**

## **I. Introduction**

### **A. Purpose of the Study**

This research study undertakes a comprehensive examination of existing observability, debugging, and tracing tools, with a particular emphasis on those operating within the Elixir, Erlang, and broader BEAM (Bogdan's Erlang Abstract Machine) ecosystem. The primary objective is to identify and analyze tools that either compete with or share similar architectural philosophies with "ElixirScope." The investigation specifically targets tools employing compile-time Abstract Syntax Tree (AST) manipulation for deep instrumentation, those offering "Execution Cinema" or time-travel debugging capabilities, and systems leveraging Artificial Intelligence (AI) or Large Language Models (LLMs) for guiding instrumentation or analysis. By dissecting the landscape of these advanced tools, this report aims to contextualize ElixirScope's position and highlight key advancements and remaining challenges in BEAM system introspection.

### **B. Scope and Focus**

The scope of this report is intentionally focused on three advanced paradigms critical to next-generation debugging and observability. First, it delves into tools that utilize compile-time AST manipulation to achieve deep code instrumentation. This approach allows for granular data capture with minimal runtime overhead, providing rich context for debugging and analysis.1 Second, the study investigates "Execution Cinema" and time-travel debugging capabilities, which enable developers to record, replay, and navigate program execution history, offering a powerful method for diagnosing complex, hard-to-reproduce bugs.4 Third, the report explores the emerging integration of AI and LLMs for guiding instrumentation strategies and enhancing analysis of collected telemetry, moving beyond traditional reactive monitoring to more proactive and intelligent debugging assistance.1 While general observability tools are acknowledged, the core of this analysis centers on these sophisticated techniques and their application within the BEAM ecosystem.

## **II. ElixirScope: A Next-Generation Platform**

### **A. Core Features and Vision**

ElixirScope is conceptualized as a state-of-the-art introspection and debugging system specifically tailored for Elixir applications, with a particular focus on Phoenix web applications. Its overarching vision is to revolutionize how developers interact with and understand complex concurrent and distributed Elixir systems.4 The platform aims to deliver an "Execution Cinema" experience, providing total behavioral recall and intuitive time-travel debugging capabilities.1 This vision is designed to make debugging highly concurrent Elixir applications as intuitive and insightful as watching a perfectly annotated film of their execution, allowing effortless navigation through time, across processes, and granular zooming from system-wide views down to individual variable changes, all guided by AI.4

The primary goals of ElixirScope include dramatically reducing the time and effort required to diagnose and resolve bugs, providing unprecedented visibility into runtime behavior of concurrent processes and their interactions, and automating significant parts of the instrumentation and analysis process using AI.4 It also seeks to make advanced BEAM/OTP debugging techniques more accessible to a broader range of Elixir developers.4 Key features include total behavioral recall through compile-time instrumentation, AI-driven guidance for intelligent instrumentation planning and code analysis, and compile-time granularity allowing access to local variables, expression tracing, and custom logic injection with precision.1

### **B. Architectural Approach: Compile-Time First with Runtime Correlation**

ElixirScope adopts a "compile-time first" approach, which is a foundational architectural choice enabling deep instrumentation with minimal performance impact.1 This approach leverages the compile-time phase of the Elixir build process to inject instrumentation directly into the Abstract Syntax Tree (AST) of the application code. This contrasts with runtime-only instrumentation, which often relies on dynamic hooks or bytecode manipulation at execution, potentially incurring higher overhead or offering less granular control. The compile-time strategy allows ElixirScope to capture comprehensive execution history, including local variable snapshots and expression tracing, directly at the source code level.1

#### **1\. Deep Compile-Time AST Instrumentation**

ElixirScope's core differentiator lies in its deep, compile-time AST instrumentation.2 This process involves modifying the program's AST before it is compiled into BEAM bytecode, allowing for the injection of monitoring code directly into the application's logic.1 The system's "Enhanced Transformer" component is responsible for granular instrumentation, including the capture of local variables and expression tracing.1 This level of detail is critical for understanding the precise state and flow of data within a concurrent application, which is a common challenge in BEAM systems. The "Injector Helpers" provide comprehensive AST manipulation utilities, supporting instrumentation patterns for GenServer, Phoenix Controller, LiveView, and Channel components.2 This compile-time approach is designed to ensure minimal overhead, with reported figures of less than 1Âµs when disabled and less than 500ns when enabled.1 This low overhead is a significant advantage, making it suitable for production environments where performance is paramount.

#### **2\. High-Performance Data Capture Pipeline**

To handle the extensive data generated by deep instrumentation, ElixirScope incorporates a high-performance data capture pipeline.1 This pipeline is designed for efficient event ingestion and storage, ensuring that the act of collecting data does not itself become a performance bottleneck. The InstrumentationRuntime provides a high-performance runtime event capture API, supporting function entry/exit tracking with correlation IDs, local variable snapshots, and AST-correlated event reporting.1 Events are stored in a lock-free Ring Buffer capable of handling over 100k events per second, and an Ingestor processes events at ultra-fast speeds, less than 1Âµs per event target.1 A Pipeline Manager coordinates asynchronous processing with backpressure, and Data Access is managed via ETS (Erlang Term Storage) for efficient querying.1 This robust pipeline is essential for enabling features like "total behavioral recall" and time-travel debugging, as it ensures that all relevant execution data is captured and made accessible for later analysis.1

#### **3\. AI Analysis Framework**

ElixirScope integrates an AI Analysis Framework, which is a key component for intelligent instrumentation planning and code analysis.1 This framework includes LLM integration with multi-provider support (e.g., Google Gemini API, Vertex AI), an AI Orchestrator for centralized AI coordination and instrumentation planning, and a Pattern Recognizer for detecting common OTP patterns like GenServer, Supervisor, and Phoenix patterns.1 While a Code Analyzer and Predictive Execution (ML-based path and resource prediction) are still under development, the existing components demonstrate a proactive approach to leveraging AI in debugging.1 The AI Orchestrator's role in intelligent instrumentation planning suggests a significant shift in observability. Instead of merely analyzing *what happened* or *what is happening*, AI is being leveraged to decide *what* should be instrumented to optimize data collection.1 This implies an intelligent system that can dynamically adjust instrumentation points based on code analysis, observed patterns, or potential problem areas, thereby optimizing the data collection strategy and potentially reducing the overhead of capturing irrelevant data. This move from reactive to proactive AI in observability is a promising direction for more efficient and targeted debugging.

#### **4\. Compile-Time Orchestration**

The compile-time orchestration in ElixirScope is responsible for integrating AI-driven instrumentation planning directly into the build process.1 The Orchestrator handles complete instrumentation planning and AI integration, while Configuration Management allows for runtime updates to instrumentation settings.1 A planned Mix Task Integration aims to automate compile-time transformation, making it easier for developers to incorporate ElixirScope into their projects.1 This compile-time first approach, coupled with AI guidance, is a strategic architectural choice. It allows for unparalleled depth and low runtime overhead in data capture, as the instrumentation code is woven directly into the application's bytecode before execution.1 This contrasts with runtime instrumentation that might rely on dynamic hooks or bytecode manipulation at execution, which can introduce higher overhead or offer less granular control. The ability to inject instrumentation at such a fundamental level, guided by AI, positions ElixirScope to provide highly precise and efficient observability.

## **III. Deep Instrumentation via Compile-Time AST Manipulation**

### **A. The Role of AST Manipulation in Observability**

Abstract Syntax Trees (ASTs) are fundamental in compilers, serving as a structured, tree-based representation of source code.12 They encapsulate a program's structure and semantic meaning, often retaining information about original source tokens.12 This rich information makes ASTs ideal for static analysis tools and program transformation, including code instrumentation.12 Modifying the AST to collect runtime information is known as AST instrumentation, a technique used for profiling, code coverage, and generating visualizations.12 The deep level of access afforded by AST manipulation allows for highly granular data capture, such as local variable snapshots and expression tracing, which is crucial for comprehensive observability and debugging.1

### **B. Approaches to Compile-Time Instrumentation**

Compile-time instrumentation involves injecting code into an application's AST before compilation, ensuring that the observability logic is an intrinsic part of the compiled binary.1 This method generally leads to lower runtime overhead compared to dynamic instrumentation, as the instrumentation is "baked in" during the build process.1

#### **1\. Elixir Macros and Parse Transforms**

In the BEAM ecosystem, Elixir leverages a powerful macro system for compile-time metaprogramming, allowing programs to treat other programs as their data, generating, analyzing, or transforming code.13 This capability is instrumental for code instrumentation, enabling dynamic program analysis by modifying source code before or during compile-time.13 Macros can reduce errors by automating code generation, minimizing manual copy-paste operations.13 The defmacro construct in Elixir allows developers to define code that operates on ASTs, effectively "speaking the compiler's language" to build constructs that can be directly reasoned with.13 ElixirScope utilizes this capability for its core AST instrumentation, enabling features like function entry/exit tracking and local variable snapshots.1

Erlang, the foundational language for Elixir, also supports "parse transforms," which are modules that modify the Erlang AST (known as Erlang Abstract Format) before compilation.14 The dbg:fun2ms pseudo-function, for instance, uses a parse transform to translate a literal function into a match specification for tracing.15 Libraries like etran provide collections of Erlang parse transforms for various purposes, including an Elixir-like pipeline operator.16 These mechanisms allow for deep instrumentation by directly manipulating the intermediate representation of the code, which is a powerful technique for achieving comprehensive observability with minimal runtime impact.17

#### **2\. Cross-Language Examples (Go, Java)**

The concept of compile-time instrumentation extends beyond the BEAM ecosystem, demonstrating its value in other compiled languages. In Go, for instance, compile-time instrumentation for OpenTelemetry leverages the standard Go toolchain's \-toolexec mechanism.19 This allows for rewriting Go source code, including dependencies and the standard library, before it is passed to the compiler, injecting instrumentation in relevant places.19 This approach aims for zero-code, vendor-neutral instrumentation with minimal runtime performance overhead and compatibility with existing projects.19

Similarly, in Java, code instrumentation can be performed on the source code before compiling or on the bytecode itself after compiling.20 Tools like Javassist, AspectJ, and ASM support bytecode instrumentation, allowing for the addition of generated code for performance benchmarks or code coverage analysis.21 The "Mod-BEAM" framework, for example, uses model-driven engineering to convert Java classes into a modifiable model representation of the bytecode, which can then be transformed and converted back into an executable .class file.22 These examples from Go and Java underscore the architectural viability and performance benefits of compile-time or build-time instrumentation for achieving deep observability across diverse programming paradigms.

### **C. Implications for Deep Instrumentation**

The ability to perform deep instrumentation through compile-time AST manipulation carries significant implications for observability. By injecting code at this fundamental level, tools can capture highly granular data, such as local variable snapshots and expression tracing, which is often difficult or impossible with runtime-only approaches.1 This level of detail provides a much richer context for understanding program behavior, especially in complex concurrent systems where state changes rapidly. The low overhead associated with compile-time instrumentation, as seen in ElixirScope's reported sub-microsecond performance 1, makes it viable for production environments where performance impact must be minimized.

The choice of compile-time instrumentation also influences the development workflow. While it offers deep insights, it can introduce complexities related to build times and managing generated code.23 However, the payoff in terms of data fidelity and performance makes it a compelling approach for advanced debugging and observability platforms. The inherent metaprogramming capabilities of Elixir and Erlang provide a strong foundation for this kind of deep instrumentation, allowing developers to extend the language itself to meet their observability needs.13 This highlights a key advantage for the BEAM ecosystem in developing sophisticated debugging tools.

## **IV. Execution Cinema and Time-Travel Debugging**

### **A. The Concept of Time-Travel Debugging**

Time-Travel Debugging (TTD), also known as reverse debugging, is a powerful technique that allows developers to capture a trace of a process's execution and then replay it both forwards and backwards.6 This capability fundamentally alters the debugging workflow by enabling users to "rewind" their debugger session to understand the conditions that led to a bug, eliminating the need to repeatedly reproduce an issue.6 Unlike traditional crash dumps, which offer only a static snapshot, TTD captures the entire execution path, providing a comprehensive historical record.6 This approach is considered logical because the problem is at the end of a chain of events, and working backward helps uncover the origin of the issue.7 For highly concurrent systems, deterministic replay, which records non-determinism to allow for reproducible execution, is a foundational requirement for effective time-travel debugging and race condition analysis.24 The effectiveness of any TTD solution, especially in the BEAM environment, will depend on its ability to accurately capture and reproduce the precise interleaving and causal relationships of concurrent processes and message passing.24

### **B. Existing Time-Travel Debuggers (General)**

Time-travel debugging has matured across various programming languages and operating systems. Notable examples include WinDbg's TTD for Windows, which provides seamless recording and replay, allowing queries on the trace using LINQ.6 For compiled code, tools like UndoDB (formerly UDB) on Linux offer robust reverse debugging capabilities.7 Other ecosystems also feature TTD solutions, such as Chronon for Java, RevDeBug for.Net/C\#, RevPDB for Python, and Elm TTD.7 These tools generally aim to capture all necessary execution details, enable offline repeatable debugging, and facilitate collaboration by allowing traces to be shared.6 While highly effective for complex bugs, a common challenge across these tools is the significant overhead incurred during recording and the potentially large size of trace files.6

### **C. Time-Travel Debugging in the BEAM Ecosystem**

Within the Elixir and Erlang BEAM ecosystem, time-travel debugging capabilities are emerging but face distinct challenges compared to more mature solutions in other environments. "ElixirScope" explicitly aims to provide an "Execution Cinema" experience with total behavioral recall and intuitive time-travel debugging, highlighting its ambition to deliver a next-generation solution for BEAM.1

One existing proof-of-concept is "TimeTravel" for LiveView, an Elixir library that records and replays interactions in LiveView applications.5 It works by attaching to Phoenix LiveView's telemetry events and storing the socket state at each event, enabling inspection of assigns and replaying interactions to observe state changes over time.5 However, TimeTravel is acknowledged as a proof-of-concept with limitations, including no graceful restore if LiveView crashes, high memory usage, and incomplete support for LiveComponents or handle\_info callbacks.5

Erlang's rr (Record and Replay) is another tool that allows recording and replaying OS process execution, offering backward execution capabilities.27 While powerful, its weakness lies in its inability to exploit CPU multicore processing, making it potentially difficult to reproduce race conditions between concurrently running threads.27 Academic research in Erlang also explores time-travel debugging, such as "CauDEr," which focuses on causal-consistent reversibility to precisely identify and undo actions that caused misbehavior in concurrent Erlang programs.26 Similarly, the "EDD" (Erlang Declarative Debugger) prototype employs a declarative debugging approach, using debugging trees to ask questions about the validity of transitions in concurrent Erlang programs, including message passing and process creation.28 The "procrastination" technique is another academic approach designed to provoke race conditions more frequently by re-running programs with reversed event orders at identified interference points.25

The current state of time-travel debugging in BEAM reveals a significant opportunity for ElixirScope. While the concept of TTD exists through proofs-of-concept like TimeTravel and academic research tools, a robust, production-ready time-travel debugger specifically tailored for highly concurrent BEAM systems, capable of handling the complexities of process interactions and message passing, is still an area of active development. ElixirScope's "Execution Cinema" vision directly addresses this gap by aiming to provide a mature TTD experience that is visually intuitive and deeply integrated with the BEAM runtime.1 The emphasis on an "Execution Cinema" experience goes beyond mere replay; it signifies a strategic move towards a rich, visual, and intuitive experience for navigating complex concurrent behavior.1 This elevates TTD from a niche, expert-only tool to a broader, more accessible debugging paradigm, which is crucial for wider adoption in the BEAM community, where understanding concurrent interactions is paramount.

### **D. Table: Overview of Time-Travel Debugging Tools**

| Tool | Ecosystem | Core Capabilities | Maturity/Status | Key Limitations | BEAM Specificity |
| :---- | :---- | :---- | :---- | :---- | :---- |
| ElixirScope | Elixir/BEAM | Record/Replay, Backward/Forward Execution, State Inspection, Distributed System Support, AI-Guided | Prototype/Early Stage (v0.0.1) | Web interface (next priority), Mix task integration (planned) 1 | Yes |
| TimeTravel (for LiveView) | Elixir/BEAM | Record/Replay, State Inspection (LiveView socket) | Proof-of-Concept | No graceful restore on crash, High memory usage, LiveComponent/handle\_info limitations, Chrome extension manifest V2 5 | Yes |
| Erlang rr | Erlang/BEAM (OS process level) | Record/Replay, Backward/Forward Execution, State Inspection | Production-ready (OS-level) | Weakness in multicore CPU for race conditions, OS process level rather than BEAM VM level 27 | Partially (OS-level for BEAM processes) |
| CauDEr | Erlang/BEAM (Academic) | Causal-Consistent Reversibility, Backward/Forward Execution, State Inspection | Academic Research | Prototype implementation, focus on specific concurrency models 26 | Yes |
| EDD | Erlang/BEAM (Academic) | Declarative Debugging, Debugging Trees, Communication/Creation Diagrams | Academic Research | Prototype implementation, user interaction as "oracle" 28 | Yes |
| WinDbg TTD | Windows | Record/Replay, Backward/Forward Execution, State Inspection, LINQ queries | Production-ready (Commercial) | Large overhead during recording, large trace files, user-mode only, anti-virus incompatibilities 6 | No |
| Chronon | Java | Record/Replay, Backward/Forward Execution, State Inspection | Commercial | Not detailed in provided material | No |
| RevDeBug | .Net/C\# | Record/Replay, Backward/Forward Execution, State Inspection | Commercial | Not detailed in provided material | No |
| RevPDB | Python | Record/Replay, Backward/Forward Execution, State Inspection | Open Source | Not detailed in provided material | No |
| Elm TTD | Elm | Record/Replay, State Inspection | Mature (Language-specific) | Not detailed in provided material | No |

## **V. Leveraging AI/LLM for Guiding Instrumentation and Analysis**

### **A. The Evolving Role of AI in Observability and Debugging**

Artificial Intelligence is profoundly transforming the landscape of observability and debugging, shifting from reactive problem identification to proactive, intelligent assistance. AI-powered systems are increasingly capable of automating data collection and analysis, performing advanced fault diagnosis and troubleshooting, optimizing maintenance planning, and building intelligent knowledge bases for technicians.9 In the context of LLM-powered systems, LLM observability specifically tracks user input, backend processing, model response, and display, while measuring critical metrics such as token usage and error rates. Tracing the sequence of operations within these systems is paramount for effective troubleshooting and root cause analysis, especially when dealing with complex orchestration frameworks like LangChain or LlamaIndex.10 This evolution signifies a move towards systems that not only tell *what* happened but also *why* it happened and *how* to prevent it, often with minimal human intervention in routine tasks.

### **B. AI-Guided Instrumentation**

A significant advancement in observability is the application of AI to *guide* the instrumentation process itself. ElixirScope's AI Orchestrator is explicitly designed for "intelligent instrumentation planning," which implies that AI will assist in determining the optimal locations and methods for placing instrumentation points within the code.1 This capability is poised to optimize data collection for specific debugging scenarios or performance goals, moving beyond manual or heuristic-based instrumentation strategies.

The concept of AI proactively guiding instrumentation is further exemplified by Segment's Auto-Instrumentation for Customer Data Platforms (CDP).11 This AI-powered solution aims to simplify setup, automate event tracking, and enable real-time iteration by removing engineering bottlenecks in data strategy.11 It demonstrates AI's role in streamlining the *process* of instrumentation, allowing businesses to react to changing customer preferences at the speed of thought.11 Academic research also points to the potential of AI-algorithm-based instrument automatic monitoring and control systems to enhance production efficiency and improve safety and quality control, including predictive PID control and leveraging wireless sensor networks for remote information collection.30 This represents a crucial shift from reactive, post-hoc analysis to AI proactively guiding the observability process itself, optimizing *what* and \**how* data is collected, rather than just *interpreting* it after the fact. This approach is expected to lead to more efficient, targeted, and less intrusive data collection.

### **C. AI/ML for Trace Analysis, Anomaly Detection, and Root Cause Analysis**

AI and Machine Learning (ML) are becoming indispensable for analyzing trace data, detecting anomalies, and performing root cause analysis (RCA). AI-powered RCA is revolutionizing debugging by enabling faster and more accurate identification of system failures.31 These systems can automatically trace failures, analyze log data using Natural Language Processing (NLP), and recommend corrective actions in real time.31 They leverage various ML models, including transformers, convolutional neural networks (CNNs), and Bayesian networks, for fault identification, and reinforcement learning for dynamic fault resolution.31 Generative AI can even suggest potential root causes and corrective actions based on similar past incidents, significantly accelerating problem resolution.32

For anomaly detection in distributed traces, ML techniques are widely applied.33 Supervised learning methods, such as "Seer," train models on labeled traces (often generated through anomaly injection) to detect performance anomalies.33 However, these methods can be labor-intensive due to the need for extensive labeled datasets and may not cover the full spectrum of possible anomalies.33 Unsupervised learning methods, like "TraceAnomaly," operate on the assumption that trace patterns can be learned from normal system executions.33 A challenge with unsupervised approaches is ensuring that the "normal" traces used for training are truly anomaly-free and effectively incorporating historical anomalous traces.33 Despite these challenges, the integration of ML into trace analysis offers significant benefits by efficiently processing vast amounts of trace data and identifying patterns, trends, and anomalies that are difficult to detect manually.35

### **D. LLMs in Code Analysis and Debugging**

Large Language Models (LLMs) are increasingly utilized for source code analysis, demonstrating capabilities in understanding code patterns, structure, and functionality, identifying hidden patterns, improving code quality, and automating various tasks.36 This signifies a progression from purely syntactic analysis to a deeper, semantic understanding of code. This capability is critical for AI-guided instrumentation, as intelligent planning of instrumentation points requires understanding the *intent* and *logic* of the code, not merely its structure. This deeper semantic comprehension allows LLMs to suggest more relevant instrumentation points or identify subtle issues that rule-based static analysis might miss.36

In practical applications, LLMs are used for automated code review generation, identifying issues, and suggesting fixes.37 Datadog, for example, employs OpenAI's GPT-4 for "AI-suggested Fixes" in its Static Code Analysis (SAST) for complex violations.39 LLMs can also generate sample code snippets to assist users with understanding syntax and troubleshooting.40

Despite these advancements, challenges persist. LLMs excel at detecting syntactic clones but struggle with semantic clones, and there is a potential bias towards LLM-generated datasets.38 Developers are cautioned against "over-reliance on AI," "ignoring the fundamentals," and "not considering AI's limitations," emphasizing the enduring need for human oversight and verification.32 LLMs may not fully grasp project-specific architecture, business logic, or internal dependencies, necessitating human validation of AI-generated suggestions.41 The Elixir ecosystem is also seeing growth in LLM integration, with libraries like llm\_composer simplifying interaction with models such as OpenAI and Ollama, supporting features like auto-execution of functions and customizable prompts.42 This indicates a growing infrastructure within Elixir to leverage LLMs for advanced applications, including potentially for debugging and observability. The enduring importance of the human-in-the-loop for AI-powered debugging is a crucial consideration. While AI can automate routine tasks and provide valuable insights, complex debugging scenarios, especially in highly specialized BEAM systems, will likely continue to require human judgment and intervention. This suggests that AI in debugging and observability will remain an assistant, augmenting human capabilities rather than fully replacing them.

### **E. Table: AI/LLM Integration in Observability and Debugging**

| Tool/Concept | Primary Application Area | AI/ML Methodologies | Key Benefits | Current Challenges/Limitations |
| :---- | :---- | :---- | :---- | :---- |
| ElixirScope AI Framework | Instrumentation Planning, Code Analysis, Pattern Recognition, Predictive Execution | LLM Integration (Gemini, Vertex AI), AI Orchestration, Pattern Recognition, ML-based Prediction | Intelligent instrumentation planning, Centralized AI coordination, OTP pattern detection 1 | Code Analyzer (basic), Predictive Execution (ðŸš§) 1 |
| Segment Auto-Instrumentation | Automated Event Tracking, Data Strategy | AI-powered suggestions | Simplifies setup, Automates event tracking, Real-time iteration, Reduces engineering bottlenecks 11 | Focus on customer data platforms, not general code debugging 11 |
| AI-powered Root Cause Analysis (RCA) | Fault Diagnosis, Root Cause Identification, Predictive Failure Analysis | NLP for log analysis, Reinforcement Learning, Anomaly Detection Models (Transformers, CNNs, Bayesian Networks), Generative AI | Faster/accurate failure ID, Automated log analysis, Predictive remediation, Enhanced DevOps efficiency 31 | Model drift, Data inconsistencies, Adversarial attacks, Human oversight required 31 |
| ML Anomaly Detection (Supervised) | Anomaly Detection in Distributed Traces | Deep Neural Networks (CNN, LSTM), Variational Autoencoders | Detects performance anomalies, Identifies affected services 33 | Dependency on anomaly injection, Laborious labeling, Limited anomaly coverage 33 |
| ML Anomaly Detection (Unsupervised) | Anomaly Detection in Distributed Traces | Deep Bayesian Neural Networks, Principal Component Analysis | Determines likelihood of normal trace, Checks for unseen call paths 33 | Assumption of anomaly-free normal traces, Difficulty incorporating historical anomalies 33 |
| LLM Code Analysis/Fixes (e.g., Datadog SAST) | Code Review, Bug Detection, Code Fix Suggestions | GPT-4 (OpenAI), Pattern Recognition, Semantic Understanding | Automates code review, Identifies issues, Suggests fixes, Generates sample code 36 | Syntactic vs. semantic challenges, Potential bias, Over-reliance risks, Contextual awareness limitations 38 |

## **VI. Wider BEAM Ecosystem Observability and Tracing Landscape**

### **A. Native Erlang/OTP Debugging Tools**

The BEAM virtual machine and its foundational languages, Erlang and Elixir, offer a robust set of built-in tools for observability and debugging, providing a strong foundation for advanced introspection. These native capabilities are often a distinguishing factor when comparing BEAM to other runtime environments.

The Erlang/OTP distribution includes graphical and text-based debugging tools. :debugger is a graphical tool that allows developers to set breakpoints, step through code, and inspect variables during runtime.43 While powerful for interactive debugging, it requires the code to be available, and Elixir variables may appear "in a weird way" due to Erlang's underlying representation.43

For more extensive tracing, the :dbg module provides a text-based interface.15 It can trace function calls, processes, and messages across local and remote nodes within a cluster.15 Instrumentation with :dbg is achieved by setting trace flags on processes (dbg:p/2) and defining trace patterns (dbg:tp/2, dbg:tpl/4) using match specifications, which act as "regex for functions".15 The data captured includes the caller PID, module, function name, arguments, and timestamp.43 A notable limitation is that its default output is often "not Elixir-friendly" 43, necessitating custom handler functions to format traces for better readability by Elixir developers.43

:observer is another standard graphical tool within BEAM for monitoring system-wide metrics, processes, applications, and network activity, providing a high-level overview of the system's health. Beyond these, Elixir and Erlang provide fundamental process inspection utilities, which are core to BEAM's actor-model concurrency.45 These include Process.whereis/1 for finding PIDs by registered names, Process.list/0 for listing all running PIDs, and Process.info/1,2 for inspecting an individual process's internal state, including its status (e.g., "running," "waiting," "exiting").45 This inherent capability, described as making "observability in Elixir... vastly different experience than that of 'most programming languages'" 45, offers a significant advantage compared to other runtimes that require extensive external tooling for basic introspection. This strong foundation makes the BEAM ecosystem a fertile ground for advanced observability solutions like ElixirScope, as they can build upon these robust, low-level primitives rather than having to create them from scratch.

Profiling tools such as eprof and fprof are also available to measure time usage in Erlang programs, with fprof utilizing trace-to-file to minimize runtime performance impact.46 Additionally, cover provides code coverage analysis, counting line executions and adding extra information to modules before compilation.46 While rr (Record and Replay) is an OS-level tool, it can be used with BEAM processes to record and replay execution, offering backward execution capabilities.27

### **B. OpenTelemetry Adoption and its Role in Standardized BEAM Observability**

OpenTelemetry has emerged as a critical, vendor-agnostic standard for collecting telemetry data, encompassing traces, metrics, and logs.47 Its primary purpose is to provide a unified API for instrumentation, allowing developers to instrument their code once and export data to various telemetry backends without vendor lock-in.47

For Erlang/Elixir applications, adopting OpenTelemetry involves adding opentelemetry\_api (for interfaces) and opentelemetry (for the SDK implementation) as dependencies.47 The SDK initializes a global TracerProvider, which then creates Tracer instances for each OTP application.47 Developers can create spans using macros like ?with\_span (Erlang) or OpenTelemetry.Tracer.with\_span (Elixir) for active spans, and start\_span for spans not tied to a specific process, which is crucial for tracing across BEAM's concurrent processes.47 Attributes, including semantic attributes, and events can be added to spans to enrich trace information.47 Integrations are available for common Elixir frameworks like Phoenix, LiveView, and Ecto, streamlining the process of collecting telemetry from web applications.48

OpenTelemetry's primary value proposition is to provide a standardized format and transport for observability data, rather than a mechanism for *deep instrumentation* itself.47 It can consume data from deep instrumentation tools but does not dictate *how* that deep data is collected. This means that tools like ElixirScope, which perform deep compile-time AST instrumentation, could potentially export their rich, high-fidelity data via OpenTelemetry, thereby bridging the gap between specialized, deep insights and standardized, portable telemetry for broader ecosystem integration. This approach combines the benefits of granular, low-overhead data capture with interoperability across diverse observability platforms.

### **C. Other Relevant Observability Concepts**

Beyond the core debugging and tracing tools, other observability concepts are vital for comprehensive system understanding in the BEAM ecosystem. The :telemetry library in Elixir is a powerful mechanism for emitting and consuming events, serving as a foundational layer for metrics and traces.49 Phoenix LiveView, for example, emits telemetry events that other tools, like TimeTravel, can attach to for data capture.5 Metrics and structured logging are recognized as essential "pillars of observability" alongside traces.49 Metrics, in particular, are crucial for analyzing trends, identifying performance bottlenecks, and assessing overall system health over time.49 The Elixir community actively engages with these concepts, as evidenced by conference talks on "Observable Elixir" that delve into structured logging, metrics with PromEx for Prometheus, and the state of OpenTelemetry for BEAM.49

A persistent challenge in the BEAM ecosystem is the gap between the power of low-level tracing tools and their usability for high-level debugging. Native BEAM tools like :dbg offer immense power for low-level tracing but present a steep learning curve and often produce "not Elixir-friendly" output 43, requiring significant effort to interpret. Conversely, higher-level tools like TimeTravel for LiveView offer better usability but are limited in scope or maturity.5 This creates a dichotomy where deep data is hard to consume, and user-friendly tools often lack the depth or breadth needed for complex concurrent systems. This reinforces ElixirScope's "Execution Cinema" vision as a crucial step towards bridging this usability gap by providing a high-level, visual interface over deep, low-level data, thereby making advanced BEAM debugging techniques more accessible and intuitive.4

## **VII. Conclusion and Future Outlook**

### **A. Synthesis of Findings: How Existing Tools Align with or Diverge from ElixirScope's Vision**

ElixirScope represents an ambitious and significant advancement in BEAM observability and debugging, distinguishing itself by integrating three cutting-edge approaches: deep compile-time Abstract Syntax Tree (AST) instrumentation, an "Execution Cinema" experience for time-travel debugging, and AI-driven guidance for both instrumentation and analysis.

The platform leverages the BEAM ecosystem's inherent metaprogramming capabilities, including Erlang parse transforms and Elixir macros, to achieve low-overhead, high-granularity data capture. This compile-time approach allows ElixirScope to instrument code at a depth often unattainable by runtime-only solutions, providing precise insights into local variables and expression tracing with minimal performance impact.1

While the concept of time-travel debugging exists within the BEAM community through proofs-of-concept like TimeTravel for LiveView 5, and academic research tools such as CauDEr and EDD 26, these tools often have limitations in maturity, scope, or usability for complex, highly concurrent BEAM systems. Even OS-level tools like rr face challenges in reproducing race conditions in multicore environments.27 ElixirScope's "Execution Cinema" vision directly addresses this gap by aiming to deliver a more mature, integrated, and visually intuitive time-travel debugging experience, making advanced debugging techniques more accessible and efficient for Elixir developers.4

Furthermore, ElixirScope's proactive AI for instrumentation planning and analysis pushes beyond traditional reactive AI observability, where AI primarily analyzes collected data.1 By intelligently guiding *where* and *how* to instrument, ElixirScope sets a new standard for intelligent debugging assistants, optimizing data collection and focusing analysis efforts.1

The wider BEAM ecosystem provides a strong foundation with native tools like :dbg and Process.info, which offer powerful low-level introspection.43 The growing adoption of OpenTelemetry also provides a standardization layer for collecting and exporting telemetry.47 However, these native tools often lack the integrated depth, visual usability, and advanced AI-driven features that ElixirScope is building, highlighting ElixirScope's unique position in bridging the gap between raw BEAM power and high-level debugging usability.

### **B. Identification of Key Strengths and Weaknesses Across the Analyzed Approaches**

**Strengths:**

* **Compile-time AST Instrumentation:** This approach offers unparalleled depth and low runtime overhead for data capture, as demonstrated by ElixirScope and cross-language examples in Go and Java.1 The BEAM's native metaprogramming capabilities significantly simplify the implementation of such deep instrumentation.13  
* **Time-Travel Debugging:** The ability to deterministically replay program execution is invaluable for diagnosing complex, hard-to-reproduce bugs, particularly in concurrent and distributed systems.6 Mature commercial tools like WinDbg TTD and UndoDB showcase the power of this paradigm.6  
* **AI/LLM Integration:** AI and LLMs significantly enhance analysis capabilities, automate routine tasks, and show substantial promise for guiding instrumentation and developing a deeper semantic understanding of code.1  
* **BEAM Native Observability:** The BEAM VM provides a robust, built-in foundation for observability, particularly concerning process management and low-level tracing, offering a distinct advantage over other runtimes that require extensive external tooling for basic introspection.43

**Weaknesses/Challenges:**

* **Compile-time Complexity:** While powerful, compile-time instrumentation can lead to increased build times and larger compiled artifact sizes, as noted in discussions of Elixir macros anti-patterns.23  
* **Time-Travel Debugging Overhead and Data Volume:** Significant performance impact during recording and the generation of very large trace files remain common challenges for TTD solutions.6 The maturity of production-ready TTD specifically for BEAM's complex concurrency models is still evolving, with existing tools often being prototypes or having specific limitations.5  
* **AI Limitations:** Despite rapid advancements, AI and LLMs in debugging carry risks of over-reliance, potential biases, and often necessitate human oversight for complex, context-dependent issues where AI's lack of project-specific context can lead to incorrect suggestions.32 Semantic understanding for LLMs, while improving, is still an active research area.  
* **Usability Gap:** A persistent challenge in the BEAM ecosystem is the translation of raw, powerful low-level tracing data into intuitive, actionable insights for developers. Native tracing tools often lack user-friendly interfaces, requiring significant effort to interpret raw data.43

### **C. Emerging Trends and Promising Research Directions in BEAM Observability, Debugging, and AI Integration**

The landscape of observability and debugging is rapidly evolving, with several key trends and promising research directions:

* **Integrated Observability Platforms:** The industry is moving towards unified solutions that combine tracing, metrics, logging, and advanced debugging features into a single, cohesive experience, moving away from fragmented tooling. ElixirScope, with its "Execution Cinema" vision and comprehensive data capture pipeline, exemplifies this trend by integrating deep instrumentation, time-travel debugging, and AI analysis into a single platform.1  
* **AI-Driven Automation and Optimization:** AI's role is expanding from post-hoc analysis to proactive guidance. Future systems will increasingly leverage AI to intelligently guide instrumentation placement, optimize data collection strategies, and provide predictive insights into system behavior and potential failures.1 This will lead to more efficient and targeted observability, reducing the overhead of collecting irrelevant data.  
* **Advanced Deterministic Replay for Concurrency:** Continued research into efficient and robust deterministic replay mechanisms, particularly for highly concurrent and distributed systems like those on BEAM, is crucial. This includes exploring causal-consistent approaches (as seen in CauDEr 26) and sophisticated scheduling manipulation techniques (like "procrastination" 25) to minimize overhead and accurately reproduce complex race conditions.  
* **Semantic Code Understanding with LLMs:** As LLMs become more adept at understanding code semantics rather than just syntax, their role in guiding debugging, suggesting fixes, and providing context-aware instrumentation will expand significantly.36 This will make debugging more intelligent, less manual, and more tailored to the specific logic of an application.  
* **Hybrid Instrumentation Approaches:** Combining the strengths of compile-time instrumentation (for deep, low-overhead data capture) with runtime mechanisms (for dynamic adjustments and less invasive monitoring) could offer optimal flexibility and performance. This allows for rich, detailed data collection where needed, while maintaining adaptability for production environments.

### **D. Potential for Hybrid Solutions and Continued Innovation**

The future of BEAM observability likely lies in hybrid solutions that strategically leverage the platform's inherent strengthsâ€”such as lightweight processes, efficient message passing, and powerful metaprogramming capabilitiesâ€”with advanced techniques like compile-time AST manipulation and AI-driven analysis.

Integrating ElixirScope's deep, AI-guided AST instrumentation with standardized telemetry formats, such as OpenTelemetry, presents a compelling path forward. This synergy could offer the best of both worlds: high-fidelity, context-rich data from deep instrumentation combined with broad compatibility and seamless integration into existing enterprise observability stacks.47 Such a hybrid approach would allow developers to gain unparalleled insights into their BEAM applications while maintaining interoperability and scalability.

The unique properties of the BEAM VM, particularly its actor model and fault-tolerance mechanisms, continue to make it a fertile ground for groundbreaking research and development in observability and debugging. The challenges posed by highly concurrent and distributed systems necessitate innovative solutions that go beyond traditional debugging paradigms. Tools like ElixirScope, by pushing the boundaries of compile-time instrumentation, time-travel debugging, and AI integration, are poised to significantly enhance the developer experience and the reliability of BEAM-based applications in an increasingly complex software landscape.

#### **Works cited**

1. ElixirScope: AI-Powered Execution Cinema Debugger for Elixir â€” elixir\_scope v0.0.1, accessed May 27, 2025, [https://hexdocs.pm/elixir\_scope/](https://hexdocs.pm/elixir_scope/)  
2. elixir\_scope \- 0.0.1 \- HexDocs, accessed May 27, 2025, [https://hexdocs.pm/elixir\_scope/elixir\_scope.epub](https://hexdocs.pm/elixir_scope/elixir_scope.epub)  
3. elixir\_scope \- Hex.pm, accessed May 27, 2025, [https://hex.pm/packages/elixir\_scope](https://hex.pm/packages/elixir_scope)  
4. ElixirScope \- Introspection and Debugging \- Libraries \- Elixir Programming Language Forum, accessed May 27, 2025, [https://elixirforum.com/t/elixirscope-introspection-and-debugging/70972](https://elixirforum.com/t/elixirscope-introspection-and-debugging/70972)  
5. TimeTravel \- A Record/Replay debugger for LiveView \- Libraries ..., accessed May 27, 2025, [https://elixirforum.com/t/timetravel-a-record-replay-debugger-for-liveview/52333](https://elixirforum.com/t/timetravel-a-record-replay-debugger-for-liveview/52333)  
6. Time Travel Debugging \- Overview \- Windows drivers | Microsoft Learn, accessed May 27, 2025, [https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview)  
7. Reverse Debugging / Time Travel Debugging: A Brief History of ..., accessed May 27, 2025, [https://undo.io/resources/reverse-debugging-time-travel-debugging-brief-hist/](https://undo.io/resources/reverse-debugging-time-travel-debugging-brief-hist/)  
8. AI Observability | Fiddler AI, accessed May 27, 2025, [https://www.fiddler.ai/ai-observability](https://www.fiddler.ai/ai-observability)  
9. How AI Can Be a Powerful Assistant for Instrumentation Technicians \- Just Measure it, accessed May 27, 2025, [https://zeroinstrument.com/how-ai-can-be-a-powerful-assistant-for-instrumentation-technicians/](https://zeroinstrument.com/how-ai-can-be-a-powerful-assistant-for-instrumentation-technicians/)  
10. What is LLM Observability? | IBM, accessed May 27, 2025, [https://www.ibm.com/think/topics/llm-observability](https://www.ibm.com/think/topics/llm-observability)  
11. AI-ready Instrumentation from the ground-up, with Auto-Instrumentation | Twilio Segment, accessed May 27, 2025, [https://segment.com/blog/ai-ready-instrumentation/](https://segment.com/blog/ai-ready-instrumentation/)  
12. AST Instrumentation (examples by language) \- Adam Rehn, accessed May 27, 2025, [https://adamrehn.com/articles/ast-instrumentation-examples-by-language/](https://adamrehn.com/articles/ast-instrumentation-examples-by-language/)  
13. An Introduction to Metaprogramming in Elixir \- AppSignal Blog, accessed May 27, 2025, [https://blog.appsignal.com/2021/09/07/an-introduction-to-metaprogramming-in-elixir.html](https://blog.appsignal.com/2021/09/07/an-introduction-to-metaprogramming-in-elixir.html)  
14. compiler v8.6.1 \- Erlang, accessed May 27, 2025, [https://www.erlang.org/doc/apps/compiler/compile.html](https://www.erlang.org/doc/apps/compiler/compile.html)  
15. dbg \- Erlang, accessed May 27, 2025, [https://www.erlang.org/docs/24/man/dbg](https://www.erlang.org/docs/24/man/dbg)  
16. Collection of Erlang parse transforms \- HexDocs, accessed May 27, 2025, [https://hexdocs.pm/etran/0.1.1/index.html](https://hexdocs.pm/etran/0.1.1/index.html)  
17. (PDF) High-performance technical computing with erlang \- ResearchGate, accessed May 27, 2025, [https://www.researchgate.net/publication/221211398\_High-performance\_technical\_computing\_with\_erlang](https://www.researchgate.net/publication/221211398_High-performance_technical_computing_with_erlang)  
18. Systematic Testing for Detecting Concurrency Errors in Erlang Programs \- Maria Christakis, accessed May 27, 2025, [https://mariachris.github.io/Pubs/ICST-2013.pdf](https://mariachris.github.io/Pubs/ICST-2013.pdf)  
19. Alibaba, Datadog, and Quesma Join Forces on Go Compile-Time ..., accessed May 27, 2025, [https://opentelemetry.io/blog/2025/go-compile-time-instrumentation/](https://opentelemetry.io/blog/2025/go-compile-time-instrumentation/)  
20. Instrumentation and Bytecode Manipulation : r/javahelp \- Reddit, accessed May 27, 2025, [https://www.reddit.com/r/javahelp/comments/1j3qydn/instrumentation\_and\_bytecode\_manipulation/](https://www.reddit.com/r/javahelp/comments/1j3qydn/instrumentation_and_bytecode_manipulation/)  
21. How to save instrumented java bytecode by Java Agent? \- Stack Overflow, accessed May 27, 2025, [https://stackoverflow.com/questions/44528565/how-to-save-instrumented-java-bytecode-by-java-agent](https://stackoverflow.com/questions/44528565/how-to-save-instrumented-java-bytecode-by-java-agent)  
22. Code instrumentation with Mod-BEAM \- University of Twente Student Theses, accessed May 27, 2025, [http://essay.utwente.nl/79040/1/Wiedijk\_MA\_EEMCS.pdf](http://essay.utwente.nl/79040/1/Wiedijk_MA_EEMCS.pdf)  
23. Meta-programming anti-patterns â€” Elixir v1.19.0-dev \- HexDocs, accessed May 27, 2025, [https://hexdocs.pm/elixir/main/macro-anti-patterns.html](https://hexdocs.pm/elixir/main/macro-anti-patterns.html)  
24. Deterministic Replay | Request PDF \- ResearchGate, accessed May 27, 2025, [https://www.researchgate.net/publication/282351631\_Deterministic\_Replay](https://www.researchgate.net/publication/282351631_Deterministic_Replay)  
25. Controlled Scheduling of Concurrent Elixir Programs | Request PDF, accessed May 27, 2025, [https://www.researchgate.net/publication/383509806\_Controlled\_Scheduling\_of\_Concurrent\_Elixir\_Programs](https://www.researchgate.net/publication/383509806_Controlled_Scheduling_of_Concurrent_Elixir_Programs)  
26. Reversible debugging of concurrent Erlang programs: Supporting imperative primitives | Request PDF \- ResearchGate, accessed May 27, 2025, [https://www.researchgate.net/publication/377480425\_Reversible\_debugging\_of\_concurrent\_Erlang\_programs\_Supporting\_imperative\_primitives](https://www.researchgate.net/publication/377480425_Reversible_debugging_of_concurrent_Erlang_programs_Supporting_imperative_primitives)  
27. Debugging NIFs and Port Drivers â€” Erlang System Documentation v28.0, accessed May 27, 2025, [https://www.erlang.org/doc/system/debugging.html](https://www.erlang.org/doc/system/debugging.html)  
28. maude.sip.ucm.es, accessed May 27, 2025, [https://maude.sip.ucm.es/\~adrian/files/tr\_03\_16.pdf](https://maude.sip.ucm.es/~adrian/files/tr_03_16.pdf)  
29. Artificial Intelligence in Process Instrumentation \- Fluid Handling Pro, accessed May 27, 2025, [https://fluidhandlingpro.com/fluid-process-technology/fluid-flow-control-measurement/artificial-intelligence-in-process-instrumentation/](https://fluidhandlingpro.com/fluid-process-technology/fluid-flow-control-measurement/artificial-intelligence-in-process-instrumentation/)  
30. (PDF) The Analysis of Instrument Automatic Monitoring and Control Systems Under Artificial Intelligence \- ResearchGate, accessed May 27, 2025, [https://www.researchgate.net/publication/377857112\_The\_Analysis\_of\_Instrument\_Automatic\_Monitoring\_and\_Control\_Systems\_Under\_Artificial\_Intelligence](https://www.researchgate.net/publication/377857112_The_Analysis_of_Instrument_Automatic_Monitoring_and_Control_Systems_Under_Artificial_Intelligence)  
31. (PDF) AI-Powered Root Cause Analysis: Transforming Software ..., accessed May 27, 2025, [https://www.researchgate.net/publication/390244658\_AI-Powered\_Root\_Cause\_Analysis\_Transforming\_Software\_Debugging\_and\_Recovery](https://www.researchgate.net/publication/390244658_AI-Powered_Root_Cause_Analysis_Transforming_Software_Debugging_and_Recovery)  
32. The Power of AI in Root Cause Analysis \- EasyRCA, accessed May 27, 2025, [https://easyrca.com/blog/the-power-of-ai-in-root-cause-analysis/](https://easyrca.com/blog/the-power-of-ai-in-root-cause-analysis/)  
33. lup.lub.lu.se, accessed May 27, 2025, [https://lup.lub.lu.se/search/files/165150749/Real\_Time\_Anomaly\_Detection\_Using\_Distributed\_Tracing\_in\_Microservice\_Cloud\_Applications.pdf](https://lup.lub.lu.se/search/files/165150749/Real_Time_Anomaly_Detection_Using_Distributed_Tracing_in_Microservice_Cloud_Applications.pdf)  
34. Machine Learning for Anomaly Detection: Use Cases and Guidelines \- Itransition, accessed May 27, 2025, [https://www.itransition.com/machine-learning/anomaly-detection](https://www.itransition.com/machine-learning/anomaly-detection)  
35. Eclipse TMLL (Trace Server Machine Learning Library), accessed May 27, 2025, [https://projects.eclipse.org/proposals/eclipse-tmll-trace-server-machine-learning-library](https://projects.eclipse.org/proposals/eclipse-tmll-trace-server-machine-learning-library)  
36. Large Language Models (LLMs) for Source Code Analysis: applications, models and datasets \- arXiv, accessed May 27, 2025, [https://arxiv.org/html/2503.17502v1](https://arxiv.org/html/2503.17502v1)  
37. Combining Large Language Models with Static Analyzers for Code Review Generation The replication package is available at https://github.com/ImenJaoua/Hybrid-Code-Review and the data is available at https://zenodo.org/records/14061110. \- arXiv, accessed May 27, 2025, [https://arxiv.org/html/2502.06633v1](https://arxiv.org/html/2502.06633v1)  
38. Exploring the Boundaries Between LLM Code Clone Detection and Code Similarity Assessment on Human and AI-Generated Code \- MDPI, accessed May 27, 2025, [https://www.mdpi.com/2504-2289/9/2/41](https://www.mdpi.com/2504-2289/9/2/41)  
39. Static Code Analysis (SAST) \- Datadog Docs, accessed May 27, 2025, [https://docs.datadoghq.com/security/code\_security/static\_analysis/](https://docs.datadoghq.com/security/code_security/static_analysis/)  
40. Artificial Intelligence (AI) Guidance | U.S. Department of Education, accessed May 27, 2025, [https://www.ed.gov/about/ed-overview/artificial-intelligence-ai-guidance](https://www.ed.gov/about/ed-overview/artificial-intelligence-ai-guidance)  
41. AI-Powered Debugging: The Future of Fixing Your Code \- WeAreDevelopers, accessed May 27, 2025, [https://www.wearedevelopers.com/en/magazine/553/ai-powered-debugging-the-future-of-fixing-your-code-553](https://www.wearedevelopers.com/en/magazine/553/ai-powered-debugging-the-future-of-fixing-your-code-553)  
42. doofinder/llm\_composer: An Elixir library for integrating and orchestrating large language models (LLMs) via HTTP, supporting OpenAI, Ollama, and other future backends. \- GitHub, accessed May 27, 2025, [https://github.com/doofinder/llm\_composer](https://github.com/doofinder/llm_composer)  
43. Debugging and Tracing in Erlang | AppSignal Blog, accessed May 27, 2025, [https://blog.appsignal.com/2023/01/10/debugging-and-tracing-in-erlang.html](https://blog.appsignal.com/2023/01/10/debugging-and-tracing-in-erlang.html)  
44. dbg â€” runtime\_tools v2.2 \- Erlang, accessed May 27, 2025, [https://www.erlang.org/doc/apps/runtime\_tools/dbg.html](https://www.erlang.org/doc/apps/runtime_tools/dbg.html)  
45. Elixir Processes: Observability \- Samuel Mullen, accessed May 27, 2025, [https://samuelmullen.com/articles/elixir-processes-observability](https://samuelmullen.com/articles/elixir-processes-observability)  
46. Tools \- Erlang, accessed May 27, 2025, [https://erlang.org/documentation/doc-5.6/pdf/tools.pdf](https://erlang.org/documentation/doc-5.6/pdf/tools.pdf)  
47. Instrumentation | OpenTelemetry, accessed May 27, 2025, [https://opentelemetry.io/docs/languages/erlang/instrumentation/](https://opentelemetry.io/docs/languages/erlang/instrumentation/)  
48. Elixir Opentelemetry Instrumentation \- SigNoz, accessed May 27, 2025, [https://signoz.io/docs/instrumentation/opentelemetry-elixir/](https://signoz.io/docs/instrumentation/opentelemetry-elixir/)  
49. Free Video: Observable Elixir \- Making Elixir Systems Observable from Code Sync | Class Central, accessed May 27, 2025, [https://www.classcentral.com/course/youtube-observable-elixir-bernardo-amorim-elixirconf-eu-2022-347184](https://www.classcentral.com/course/youtube-observable-elixir-bernardo-amorim-elixirconf-eu-2022-347184)