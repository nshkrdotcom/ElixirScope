## === 7-integration_architecture.ex ===
defmodule ElixirScope.ASTRepository.IntegrationArchitecture do
  @moduledoc """
  Defines the integration architecture for the Enhanced AST Repository
  with other ElixirScope components.

  This module outlines how the AST Repository (with its CFG, DFG, CPG capabilities)
  interacts with:
  - Instrumentation Runtime & Mapper
  - Temporal Storage & Bridge
  - Query Engine
  - AI Components (CodeAnalyzer, PatternRecognizer, LLM interfaces)
  - Future UI / Visualization Layers

  It focuses on data flow, API contracts, and event-driven coordination.
  """

  # --- Core Concepts for Integration ---

  @doc """
  AST Node ID Schema:
  The AST Node ID is crucial for correlating static analysis with runtime events.
  Schema: `module_id:function_id:ast_path_hash`
  - `module_id`: Typically `Module.concat([Module, Name])` or similar unique module identifier.
  - `function_id`: `function_name_arity_clause_index` (e.g., `my_func_2_0`).
  - `ast_path_hash`: A hash or unique path identifier representing the node's position
                     within its function's AST (e.g., generated by traversing from root).
  This ID must be stable across compilations if the code structure hasn't changed.
  """
  def ast_node_id_schema_info do
    %{
      description: "Unique identifier for an AST node, stable across compilations.",
      format: "module_id:function_id:ast_path_hash",
      example: "Elixir.MyApp.UserManager:handle_call_3_0:a3f5b1c7"
    }
  end

  # --- Integration Points & Data Flow ---

  @doc """
  1. Compile-Time: ASTRepository Population and Instrumentation Mapping

  ASTParser -> EnhancedASTStorage(ETS/GraphDB)
              -> CFGGenerator -> CFGData
              -> DFGGenerator -> DFGData
              -> CPGBuilder   -> CPGData (stored)

  InstrumentationMapper -> ASTRepository (queries for AST node IDs)
                        -> TransformedAST (with injected calls to InstrumentationRuntime using ASTNodeIDs)
  """
  def compile_time_flow do
    %{
      description: "During compilation, ASTs are parsed, analyzed (CFG/DFG/CPG), and stored. Instrumentation mapper uses AST Node IDs.",
      steps: [
        "Source code parsed into AST.",
        "ASTRepository.Parser assigns unique, stable AST Node IDs.",
        "Enhanced AST, CFG, DFG, CPG are generated and stored in ASTRepository.",
        "InstrumentationMapper queries ASTRepository for node IDs of constructs to be instrumented.",
        "ASTTransformer injects calls to InstrumentationRuntime, embedding these AST Node IDs."
      ],
      key_data: [:ast_node_id, :cpg_data]
    }
  end

  @doc """
  2. Runtime: Event Capture and Correlation

  InstrumentedCode -> InstrumentationRuntime.report_*(..., ast_node_id, ...)
                   -> EventIngestor -> RingBuffer -> PipelineManager
                   -> EventStore (raw events with ast_node_id)
                   -> TemporalStorage (time-indexed events with ast_node_id)
  """
  def runtime_flow do
    %{
      description: "At runtime, instrumented code emits events tagged with AST Node IDs.",
      steps: [
        "Instrumented code executes, triggering calls to InstrumentationRuntime.",
        "InstrumentationRuntime functions are called with `ast_node_id` and other context.",
        "Events (function entry/exit, var snapshots, errors) are captured with their `ast_node_id`.",
        "Events are processed through the ingestion pipeline and stored in EventStore & TemporalStorage."
      ],
      key_data: [:runtime_event, :ast_node_id, :correlation_id, :timestamp]
    }
  end

  @doc """
  3. Query-Time & Analysis: Bridging Static and Dynamic Data

  QueryEngine -> ASTRepository (for CPG, static properties)
              -> TemporalStorage (for runtime events via ast_node_id or correlation_id)
              -> Results (correlated static & dynamic info)

  AIComponents -> ASTRepository (CPG for patterns, complexity)
               -> QueryEngine (runtime behavior associated with AST patterns)
               -> Insights & Recommendations
  """
  def query_analysis_flow do
    %{
      description: "Queries combine static CPG data with dynamic runtime event data using AST Node IDs.",
      components: %{
        "QueryEngine" => "Accepts queries that can span AST properties and runtime behavior. Uses ast_node_id to link.",
        "TemporalBridge" => "Facilitates time-travel by correlating historical runtime events (via ast_node_id) with static CPG views.",
        "AI.CodeAnalyzer" => "Leverages CPG for deep static analysis (e.g., data flow paths, complex patterns).",
        "AI.PatternRecognizer" => "Uses CPG to identify known good/bad code structures.",
        "AI.PredictiveAnalyzer" => "Combines CPG features with historical runtime data (queried via QueryEngine) to make predictions.",
        "CinemaDebugger" => "Visualizes execution paths on the CPG, overlays runtime values on AST representations."
      },
      key_data: [:cpg_query_result, :correlated_event_trace]
    }
  end


  # --- API Contract Ideas (Conceptual) ---

  @doc """
  ASTRepository API for other components:
  """
  def ast_repository_api_surface do
    [
      # Get CPG for a function/module
      get_cpg: %{
        params: [function_key: "{module, fun, arity}"],
        returns: "{:ok, CPGData.t()} | {:error, :not_found}"
      },
      # Find CPG node by AST Node ID
      find_cpg_node_by_ast_id: %{
        params: [ast_node_id: "string"],
        returns: "{:ok, CPGNode.t()} | {:error, :not_found}"
      },
      # Query CPG using a graph pattern language (e.g., simplified Cypher-like)
      query_cpg_pattern: %{
        params: [pattern: "map_representation_of_query"],
        returns: "{:ok, [CPGNode.t() | CPGEdge.t()]} | {:error, :invalid_query}"
      },
      # Get CFG path between two AST Node IDs
      get_cfg_path: %{
        params: [from_ast_node_id: "string", to_ast_node_id: "string"],
        returns: "{:ok, [CFGNode.t()]} | {:error, :no_path}"
      },
      # Get DFG trace for a variable (SSA version) starting at an AST Node ID
      get_dfg_trace: %{
        params: [variable_ssa_name: "string", start_ast_node_id: "string"],
        returns: "{:ok, [DFGData.DataFlow.t()]} | {:error, :not_found}"
      }
    ]
  end

  @doc """
  TemporalBridge API enhancements for AST correlation:
  """
  def temporal_bridge_ast_api do
    [
      reconstruct_state_at_ast_node: %{
        params: [ast_node_id: "string", timestamp_or_correlation_id: "term"],
        returns: "{:ok, variable_snapshots_map} | {:error, _}"
      },
      get_execution_trace_for_ast_path: %{
        params: [start_ast_node_id: "string", end_ast_node_id: "string", time_range: "{start_ts, end_ts}"],
        returns: "{:ok, [runtime_event_with_ast_context]} | {:error, _}"
      },
      find_runtime_events_for_cpg_node: %{
        params: [cpg_node_id: "string", time_range: "{start_ts, end_ts}", event_type_filter: "atom | nil"],
        returns: "{:ok, [runtime_event]}"
      }
    ]
  end

  @doc """
  AI Component interaction with AST Repository:
  """
  def ai_component_integration do
    %{
      "AI.CodeAnalyzer" => "Receives CPGData, extracts features (complexity, structure, data flows) for analysis.",
      "AI.PatternRecognizer" => "Queries ASTRepository with CPG patterns (e.g., 'find all functions calling :ets.insert within a GenServer.call').",
      "AI.ASTEmbeddings" => "Processes CPGs (or ASTs from repo) to generate vector embeddings. Stores embeddings potentially with links back to CPG node IDs.",
      "AI.PredictiveAnalyzer" => """
      1. Identifies relevant CPG features/patterns from ASTRepository.
      2. Queries QueryEngine for historical runtime data associated with similar CPG patterns (using ast_node_ids or derived features).
      3. Trains/uses ML models.
      """
    }
  end

  # --- Event-Driven Coordination ---
  @doc """
  Event-driven updates and notifications:
  """
  def event_driven_coordination do
    %{
      events: [
        # Emitted by ASTRepository.FileWatcher/Synchronizer
        %{
          name: :elixir_scope_ast_repository_updated,
          payload: %{
            type: :module_updated | :module_added | :module_deleted,
            module_name: "atom",
            changed_function_keys: "[{m,f,a}]", # For :module_updated
            new_cpg_available: "boolean"
          },
          consumers: ["QueryEngine (cache invalidation)", "AIComponents (trigger re-analysis/retraining)", "TemporalBridge (update static context)"]
        },
        # Emitted by AIComponents when new insights are available
        %{
          name: :elixir_scope_ai_insight_generated,
          payload: %{
            type: :performance_hotspot | :potential_bug | :refactoring_suggestion,
            severity: ":high | :medium | :low",
            related_ast_node_ids: "list_of_strings",
            cpg_pattern_id: "optional_string",
            description: "string",
            recommendation: "string"
          },
          consumers: ["UI/NotificationService", "InstrumentationPlanner (for adjusting strategy)"]
        }
      ],
      mechanism: "Elixir's :telemetry, or a dedicated PubSub system if more complex."
    }
  end

  # --- Key Integration Challenges & Considerations ---
  def integration_challenges do
    [
      %{
        challenge: "AST Node ID Stability & Granularity",
        description: "Ensuring AST Node IDs are stable across minor code refactors but change meaningfully for structural changes. Defining the right granularity for IDs (e.g., expression-level vs. statement-level).",
        mitigation: "Robust hashing/path-based ID generation. Versioning of ASTs/CPGs."
      },
      %{
        challenge: "Scalability of CPG Storage & Querying",
        description: "Storing and efficiently querying potentially large CPGs for entire projects.",
        mitigation: "Graph database selection, indexing strategies, query optimization, possibly sharding or sampling for very large codebases."
      },
      %{
        challenge: "Synchronization Latency",
        description: "Minimizing delay between code change, AST/CPG update, and availability for query/analysis.",
        mitigation: "Efficient incremental updates, optimized FileWatcher, asynchronous processing."
      },
      %{
        challenge: "Complexity of Correlated Queries",
        description: "Designing and optimizing queries that join deep static CPG analysis with extensive runtime event traces.",
        mitigation: "Careful schema design for both static and dynamic data, pre-materialized views or summary tables, specialized query execution strategies."
      },
      %{
        challenge: "Mapping Dynamicism to Static Graphs",
        description: "Representing dynamic dispatches, higher-order functions, and metaprogramming effectively in a static CPG and correlating them with runtime behavior.",
        mitigation: "Approximations in CPG (e.g., all possible targets for dynamic call), runtime feedback to refine static graph, special handling for known metaprogramming patterns."
      }
    ]
  end

  @doc """
  Overall integration vision:
  The Enhanced AST Repository, particularly its CPG output, becomes the central "source of truth"
  about the static structure and potential behavior of the codebase. Runtime components provide
  the "actual behavior" data, tagged to this static truth via AST Node IDs.
  All higher-level features (debugging, AI analysis, visualization) operate by querying
  and correlating these two worlds.
  """
  def vision do
    "A seamlessly integrated ecosystem where static code understanding and dynamic runtime observation empower intelligent, context-aware developer tools."
  end
end
