## ElixirScope API for MiniProcessFlow Integration & Debugging

**Objective:** To provide MiniProcessFlow developers with the necessary ElixirScope APIs to dynamically trace their application, capture rich contextual data, and retrieve that data for debugging process interactions and state changes. This focuses on validating ElixirScope's utility in an early development debugging workflow.

---

### 1. Core ElixirScope Lifecycle & Configuration APIs (for Application Setup)

These APIs are typically used once when MiniProcessFlow starts or when global ElixirScope settings need adjustment.

#### **Module: `ElixirScope`**

*   **`ElixirScope.start(opts \\ []) :: :ok | {:error, term()}`**
    *   **Purpose:** Starts the main ElixirScope application and its supervision tree, including the runtime tracing controller and backend data pipeline.
    *   **Integration with MiniProcessFlow:** Add `{ElixirScope, start_opts}` to MiniProcessFlow's `application.ex` child spec.
        ```elixir
        # In MiniProcessFlow.Application.start/2
        children = [
          MiniProcessFlow.OrderSupervisor,
          # Start ElixirScope here
          {ElixirScope, strategy: :otp_focused} # Example option
        ]
        opts = [strategy: :one_for_one, name: MiniProcessFlow.Supervisor]
        Supervisor.start_link(children, opts)
        ```
    *   **Key `opts` for MiniProcessFlow:**
        *   `strategy: :otp_focused | :minimal | :balanced | :full_runtime_trace` (Conceptual): Influences the default runtime tracing plan generated by `AI.Orchestrator`. `:otp_focused` could be a new strategy that tells the AI to prioritize tracing GenServer callbacks, state changes, and inter-process messages relevant to OTP patterns.
        *   `sampling_rate: float()` (0.0 to 1.0): A global default sampling rate if specific traces don't override it. For `MiniProcessFlow` debugging, `1.0` (100%) is recommended.
        *   `default_trace_level: :basic | :detailed | :full`: Default detail for traces if not specified per trace command.
    *   **Side Effect:** The `Runtime.Controller` will typically apply an initial runtime tracing plan (generated by `AI.Orchestrator` based on configuration and code analysis of MiniProcessFlow) upon startup.

*   **`ElixirScope.stop() :: :ok`**
    *   **Purpose:** Stops the ElixirScope application and all its tracing activities.
    *   **Integration:** Called during MiniProcessFlow shutdown or when debugging is complete.

*   **`ElixirScope.running?() :: boolean()`**
    *   **Purpose:** Checks if ElixirScope is active. Useful for conditional logic in MiniProcessFlow.

*   **`ElixirScope.Config.update([atom()], term()) :: :ok | {:error, term()}`**
    *   **Purpose:** (Advanced) Allows runtime updates to *specific, whitelisted* global ElixirScope configurations. Could be used to change global sampling or AI planning strategies if needed, though `ElixirScope.Runtime` APIs are preferred for trace-specific changes.
    *   **Example for MiniProcessFlow (via IEx):**
        ```iex
        # Change default AI planning strategy if MiniProcessFlow's AI plan needs regeneration
        ElixirScope.Config.update([:ai, :planning, :default_strategy], :full_runtime_trace)
        # Then trigger a re-analysis for MiniProcessFlow
        ElixirScope.AI.Orchestrator.analyze_and_plan(File.cwd!()) # Assuming MiniProcessFlow is CWD
        ```

---

### 2. Runtime Tracing Control APIs (for Dynamic Debugging)

These are the primary APIs a developer would use interactively (e.g., from IEx, or programmatically in test setup) to control tracing for `MiniProcessFlow`.

#### **Module: `ElixirScope.Runtime`**

*   **`ElixirScope.Runtime.trace(target :: module() | pid() | {module, atom(), arity()}, opts \\ []) :: {:ok, trace_ref :: reference()} | {:error, term()}`**
    *   **Purpose:** Starts tracing on a specific target. This is the **main workhorse** for a MiniProcessFlow developer.
    *   **`target`:**
        *   `MiniProcessFlow.OrderReceiver` (module): Trace all function calls in this module.
        *   `pid_of_order_receiver` (PID): Trace a specific instance.
        *   `{MiniProcessFlow.InventoryChecker, :handle_call, 3}` (MFA): Trace only this function.
    *   **Key `opts` for MiniProcessFlow Debugging:**
        *   `level: :basic | :detailed | :full`
            *   `:basic`: Trace function entry/exit, basic messages.
            *   `:detailed`: Capture function arguments & return values.
            *   `:full`: Maximum detail, potentially including internal state variables (future).
        *   `capture: [:state_before, :state_after, :state_diff]` (for GenServer `target` or MFA target that is a callback): Captures state snapshots around callback executions.
        *   `include: [:messages | :process_lifecycle | :call_stack]`
            *   `:messages`: Capture messages sent/received by the target PID.
            *   `:process_lifecycle`: If `target` is a PID, trace its spawn/exit/link events.
            *   `:call_stack`: Attempt to capture caller information (may have limitations with pure BEAM tracing).
        *   `include_children: boolean()` (if `target` is a PID of a supervisor): Trace child processes.
        *   `duration: {non_neg_integer(), :seconds | :minutes}`: Automatically stop trace after duration.
        *   `match_spec: list(tuple())` (Advanced): Provide a raw Erlang match specification for fine-grained filtering at the BEAM trace level. (Could use `ElixirScope.Runtime.Matchers` to build this).
    *   **Example for MiniProcessFlow:**
        ```iex
        # Trace all calls to OrderReceiver with args & returns
        {:ok, ref1} = ElixirScope.Runtime.trace(MiniProcessFlow.OrderReceiver, level: :detailed)

        # Trace a specific PaymentProcessor PID, including its messages and state changes
        # (assuming PaymentProcessor is a GenServer and AI plan configures state capture for it)
        {:ok, ref2} = ElixirScope.Runtime.trace(payment_processor_pid,
                         include: [:messages],
                         capture: [:state_before, :state_after, :state_diff],
                         level: :detailed
                       )

        # Trace only the :check_stock function in InventoryChecker
        {:ok, ref3} = ElixirScope.Runtime.trace({MiniProcessFlow.InventoryChecker, :handle_call, 3},
                         level: :full,
                         match_spec: ElixirScope.Runtime.Matchers.match_spec(fn
                           ({:check_stock, _item_id}, _from, _state) -> true
                           (_, _, _) -> false # Only trace :check_stock calls
                         end)
                       )
        ```

*   **`ElixirScope.Runtime.stop_trace(trace_ref :: reference()) :: :ok | {:error, term()}`**
    *   **Purpose:** Stops a specific trace session initiated by `trace/2`.
    *   **Example:** `ElixirScope.Runtime.stop_trace(ref1)`

*   **`ElixirScope.Runtime.list_traces() :: [map()]`**
    *   **Purpose:** Shows all currently active runtime traces, their targets, and options. Useful for managing ongoing debugging sessions.

*   **`ElixirScope.Runtime.adjust_trace(trace_ref :: reference(), adjustments :: keyword()) :: :ok | {:error, term()}`**
    *   **Purpose:** (Advanced) Modify parameters of an active trace, e.g., change `level` or `sampling_rate`.
    *   **Example:** `ElixirScope.Runtime.adjust_trace(ref2, level: :full)`

*   **`ElixirScope.Runtime.set_global_tracing_status(enabled :: boolean()) :: :ok`**
    *   **Purpose:** Quickly enable or disable all runtime tracing capture. Overrides individual trace settings but doesn't remove them.
    *   **Integration:** Could be used by MiniProcessFlow to temporarily pause ElixirScope during sensitive operations or benchmarks.

#### **APIs Related to Production Safety (Less critical for MiniProcessFlow PoC, but good to be aware of):**

*   `ElixirScope.Runtime.set_limits(limits :: keyword()) :: :ok`
*   `ElixirScope.Runtime.emergency_stop() :: {:ok, stopped_count :: integer()}`
*   `ElixirScope.Runtime.Safety.safe_to_trace?(trace_type :: atom()) :: boolean()`

---

### 3. AI Plan Inspection APIs (for understanding what the AI decided)

These are useful for the ElixirScope developer to verify that the "AI" (even rule-based for now) is generating a sensible default tracing plan for MiniProcessFlow.

#### **Module: `ElixirScope.AI.Orchestrator`**

*   **`ElixirScope.AI.Orchestrator.get_runtime_tracing_plan() :: {:ok, map()} | {:error, term()}`**
    *   **Purpose:** Retrieves the currently active runtime tracing plan that was generated by the AI based on code analysis and configuration.
    *   **Integration for MiniProcessFlow:**
        ```iex
        # See what plan ElixirScope generated for MiniProcessFlow
        {:ok, plan} = ElixirScope.AI.Orchestrator.get_runtime_tracing_plan()
        IO.inspect(plan)
        # Expected output for MiniProcessFlow:
        # %{
        #   global_trace_flags: [...],
        #   module_traces: %{
        #     MiniProcessFlow.OrderReceiver => %{otp_monitoring: :state_changes, functions: %{{:handle_call,3} => %{level: :detailed}}},
        #     MiniProcessFlow.InventoryChecker => %{...},
        #     ...
        #   },
        #  ...
        # }
        ```

*   **`ElixirScope.AI.Orchestrator.analyze_and_plan(project_path :: String.t(), opts \\ []) :: {:ok, map()} | {:error, term()}`**
    *   **Purpose:** Manually triggers a re-analysis of the specified project and generation/update of the runtime tracing plan.
    *   **Integration:** Useful if MiniProcessFlow code changes and you want ElixirScope to immediately reflect those changes in its tracing plan without a full recompile (if ElixirScope itself is already running).
        ```iex
        ElixirScope.AI.Orchestrator.analyze_and_plan(File.cwd!()) # Analyze current project (MiniProcessFlow)
        ```

---

### 4. Data Retrieval APIs (for Debugging Validation & Showcasing "Cinema Data")

These APIs are used to get the captured trace data out of ElixirScope. For the MiniProcessFlow PoC, these would be wrapped by simple `IExHelpers`.

#### **Module: `ElixirScope.Storage.DataAccess` (Direct Access - for now)**

*This is a lower-level API. The `QueryCoordinator` will be the preferred future interface.*

*   **`ElixirScope.Storage.DataAccess.query_events(storage_instance, query_conditions_map) :: {:ok, [ElixirScope.Events.t()]} | {:error, term()}`** (Conceptual - current `DataAccess` has more specific query functions like `query_by_pid`, `query_by_correlation`)
    *   **Purpose:** Generic way to fetch events. For MiniProcessFlow, we'd use the existing specific functions.
    *   **Example Usage for MiniProcessFlow:**
        ```iex
        {:ok, storage} = ElixirScope.Storage.DataAccess.get_default_storage() # Get handle to ETS tables

        # Get all events for the OrderReceiver PID in the last 60s
        since_ts = System.monotonic_time(:nanosecond) - (60 * 1_000_000_000)
        until_ts = System.monotonic_time(:nanosecond)
        {:ok, order_receiver_events} = ElixirScope.Storage.DataAccess.query_by_time_range(storage,
                                          since_ts, until_ts,
                                          filter_fn: fn event -> event.pid == order_receiver_pid end
                                        )

        # Get events by a known correlation ID (e.g., an order_id)
        {:ok, order_flow_events} = ElixirScope.Storage.DataAccess.query_by_correlation(storage, "order_correlation_123")
        ```

#### **Module: `ElixirScope.IExHelpers` (Conceptual - to be built for MiniProcessFlow PoC)**

These would wrap `DataAccess` calls.

*   **`ElixirScope.IExHelpers.show_process_history(pid :: pid() | atom(), opts \\ [])`**
    *   **Purpose:** Displays a concise history of events (function calls, messages, state changes) for a given PID or registered GenServer name.
    *   **`opts`:** `limit: integer()`, `since: timestamp()`, `event_types: [:call, :state]`.
    *   **Example:** `ElixirScope.IExHelpers.show_process_history(MiniProcessFlow.InventoryChecker, limit: 20, event_types: [:function_entry, :state_change])`
    *   **Data Displayed (Example):**
        ```
        History for MiniProcessFlow.InventoryChecker (<0.123.0>):
        [<timestamp1>] CALL MiniProcessFlow.InventoryChecker.handle_call({:check_stock, "itemA"}, ...)
        [<timestamp2>] STATE CHANGE: old: %{stock: %{"itemA"=>10}}, new: %{stock: %{"itemA"=>9}}
        [<timestamp3>] EXIT MiniProcessFlow.InventoryChecker.handle_call/3 -> {:reply, {:ok, 9}, ...}
        ...
        ```

*   **`ElixirScope.IExHelpers.show_genserver_state_timeline(pid_or_name, opts \\ [])`**
    *   **Purpose:** Specifically focuses on and displays the sequence of `StateChange` events for a GenServer.
    *   **Example:** `ElixirScope.IExHelpers.show_genserver_state_timeline(payment_processor_pid, limit: 5)`
    *   **Data Displayed:** Sequence of old state, new state, and diffs.

*   **`ElixirScope.IExHelpers.show_messages_for_pid(pid_or_name, opts \\ [])`**
    *   **Purpose:** Displays messages sent to and from the specified PID.
    *   **`opts`:** `direction: :in | :out | :both`.
    *   **Example:** `ElixirScope.IExHelpers.show_messages_for_pid(order_receiver_pid, direction: :both)`
    *   **Data Displayed:** List of `MessageSend` and `MessageReceive` events with timestamps, peer PIDs, and message content.

*   **`ElixirScope.IExHelpers.follow_correlation(correlation_id, opts \\ [])`**
    *   **Purpose:** Shows all events associated with a specific `correlation_id`.
    *   **Example:** If an order processing starts with `order_corr_xyz`, `ElixirScope.IExHelpers.follow_correlation("order_corr_xyz")` would show its journey.

---

### Using these APIs for Debugging MiniProcessFlow (Recap)

1.  **Setup:** In `MiniProcessFlow.Application`, add `ElixirScope.start(strategy: :otp_focused)` (or a similar strategy tailored for GenServer/message tracing).
2.  **Run MiniProcessFlow:** Start the application. ElixirScope's AI plan will initiate default tracing (e.g., for GenServer callbacks).
3.  **In IEx (connected to MiniProcessFlow):**
    *   Identify PIDs of interest: `pid_receiver = Process.whereis(MiniProcessFlow.OrderReceiver)`.
    *   **Ad-hoc Detailed Tracing:**
        ```iex
        {:ok, ref} = ElixirScope.Runtime.trace(pid_receiver, level: :detailed, include: [:messages], capture: [:state_before, :state_after])
        # ... trigger a new order in MiniProcessFlow ...
        ElixirScope.Runtime.stop_trace(ref)
        ```
    *   **Inspect Captured Data:**
        ```iex
        ElixirScope.IExHelpers.show_process_history(pid_receiver, limit: 30)
        # Observe calls, messages, state changes for OrderReceiver.
        # Look for the specific :new_order call. Note its correlation_id.

        # If an order seems stuck in InventoryChecker:
        pid_inventory = Process.whereis(MiniProcessFlow.InventoryChecker)
        ElixirScope.IExHelpers.show_genserver_state_timeline(pid_inventory)
        ElixirScope.IExHelpers.show_messages_for_pid(pid_inventory, direction: :in)
        ```
4.  **Scenario - Bug: InventoryChecker returns unexpected atom `:item_unavailable` instead of `{:error, :out_of_stock}`.**
    *   `ElixirScope.Runtime.trace({MiniProcessFlow.InventoryChecker, :handle_call, 3}, level: :full)`
    *   Trigger the order that uses the item.
    *   `ElixirScope.IExHelpers.show_process_history(pid_inventory)`
        *   You'll see the `FunctionEntry` for `handle_call` with args.
        *   You'll see the `FunctionExit` with `result: :item_unavailable`.
        *   You'll also see the calling process (e.g., `OrderReceiver`) potentially crashing or misbehaving because it didn't expect this atom.
5.  **"Cinema Data" Exposed:** The output of `IExHelpers` functions *is* the raw data that would populate the Execution Cinema. By seeing this structured, correlated data (timestamps, PIDs, MFAs, args, returns, state diffs, message contents, links), developers can already "manually time-travel" and understand the flow far better than with `IO.inspect`.

This API set allows MiniProcessFlow developers to dynamically control tracing and, crucially, to retrieve and inspect the rich, correlated data ElixirScope captures, thereby validating its utility for debugging typical concurrent Elixir applications. The `IExHelpers` become the first "UI" onto the "Execution Cinema" data.





### ElixirScope API for MiniProcessFlow Integration & Debugging (Continued)

---

### 2. Runtime Tracing Control APIs (for Dynamic Debugging) - Continued

#### **Module: `ElixirScope.Runtime`** - Continued

*   **`ElixirScope.Runtime.trace_when(target :: module() | {module, atom(), arity()}, condition_fun :: function(), action_opts :: keyword(), trace_opts :: keyword()) :: {:ok, trace_ref} | {:error, term()}`**
    *   **Purpose:** (Conceptual, based on `OPUS_PROD_RUNTIME_INSTRUMENTATION_API_SKETCH.md`) Allows setting up tracing that only activates when a specific runtime condition is met. This is extremely powerful for capturing data around intermittent or specific state-dependent bugs without noisy continuous tracing.
    *   `target`: The MFA or module to initially monitor lightly.
    *   `condition_fun`: A function `(module, function, args_or_return_value) -> boolean()` evaluated each time the target is hit. If it returns `true`...
    *   `action_opts`: What to do when the condition is met. Examples:
        *   `enable_trace: trace_ref_or_new_target_opts`: Activates a more detailed trace (either a previously defined one by `trace_ref` or starts a new one with `new_target_opts`).
        *   `capture_snapshot: pid_or_module`: Triggers a state snapshot via `StateMonitor`.
        *   `log_event: true`: Simply logs a specific ElixirScope event noting the condition was met.
    *   `trace_opts`: Options for the initial light monitoring of `target` (e.g., just enough to evaluate `condition_fun`).
    *   **Example for MiniProcessFlow:**
        ```iex
        # Start detailed tracing for PaymentProcessor only when an order total is > 1000
        # and the payment method is :credit_card
        condition = fn
          (MiniProcessFlow.PaymentProcessor, :handle_call, [{:process_payment, %{total: total, method: :credit_card}}, _from, _state]) ->
            total > 1000
          (_, _, _) -> false
        end

        action = [enable_trace: [level: :full, duration: {5, :minutes}]] # Trace PaymentProcessor fully for 5 mins
        initial_trace_opts = [level: :basic] # Lightly trace handle_call to check args

        ElixirScope.Runtime.trace_when(
          {MiniProcessFlow.PaymentProcessor, :handle_call, 3},
          condition,
          action,
          initial_trace_opts
        )
        ```
    *   **Implementation Note:** This would require the `Runtime.Tracer` to have the capability to evaluate the `condition_fun` within its trace handling logic (potentially with performance implications if the function is complex or frequently hit). The `action_opts` would trigger further calls to `Runtime.Controller`.

*   **`ElixirScope.Runtime.trace_pattern(message_pattern :: term(), opts :: keyword()) :: {:ok, trace_ref} | {:error, term()}`**
    *   **Purpose:** (Conceptual) Trace messages across the system that match a given `message_pattern`. Useful for tracking specific kinds of inter-process communication.
    *   `message_pattern`: An Elixir term that messages will be matched against (e.g., `{:process_item, _item_id}`).
    *   `opts`:
        *   `capture: [:full_message, :sender, :receiver, :timestamp]`
        *   `on_match: :trace_processes_for_duration` (e.g., trace sender/receiver for 1 minute upon match).
    *   **Example for MiniProcessFlow:**
        ```iex
        # Trace all instances of :critical_inventory_update messages, and trace the sender/receiver
        ElixirScope.Runtime.trace_pattern({:critical_inventory_update, _details},
          on_match: [trace_processes_for_duration: {{1, :minute}, [level: :detailed]}]
        )
        ```
    *   **Implementation Note:** This would likely involve `Runtime.Tracer` using broad message tracing (`:send`, `:receive` flags) and then filtering by the pattern, or more efficiently, generating complex BEAM match specifications from the `message_pattern` to only receive relevant trace messages.

---

### 4. Data Retrieval APIs (for Debugging Validation & Showcasing "Cinema Data") - Continued

#### **Module: `ElixirScope.Storage.QueryCoordinator` (Future Preferred Interface - Basic Functions for PoC)**

While `DataAccess` provides direct ETS access, `QueryCoordinator` is the intended higher-level API. For the MiniProcessFlow PoC, we can define a few key functions on `QueryCoordinator` that would be essential for debugging.

*   **`ElixirScope.Storage.QueryCoordinator.get_process_events(pid_or_name, opts \\ []) :: {:ok, [ElixirScope.Events.t()]} | {:error, term()}`**
    *   **Purpose:** Retrieves all known events associated with a given PID or registered name. A more user-friendly wrapper around `DataAccess` queries.
    *   **`opts`:** `limit: integer()`, `since: timestamp()`, `until: timestamp()`, `event_types: list(atom())`, `order: :asc | :desc`.
    *   **Example:** `QueryCoordinator.get_process_events(MiniProcessFlow.InventoryChecker, limit: 50, event_types: [:function_entry, :function_exit, :state_change], order: :desc)`
    *   **Implementation:** Uses `DataAccess.query_by_pid` and then filters/sorts.

*   **`ElixirScope.Storage.QueryCoordinator.get_correlated_trace(correlation_id :: term(), opts \\ []) :: {:ok, [ElixirScope.Events.t()]} | {:error, term()}`**
    *   **Purpose:** Retrieves all events belonging to a specific `correlation_id` (e.g., all events related to processing a single order).
    *   **`opts`:** `sort_by_timestamp: boolean()` (default true).
    *   **Example:** `QueryCoordinator.get_correlated_trace("order_processing_corr_123")`
    *   **Implementation:** Uses `DataAccess.query_by_correlation` and sorts.

*   **`ElixirScope.Storage.QueryCoordinator.reconstruct_genserver_state(pid_or_name, at_timestamp :: integer()) :: {:ok, map() | term()} | {:error, :no_snapshot_found | term()}`**
    *   **Purpose:** Reconstructs the state of a GenServer as it was at (or just before) a specific monotonic timestamp.
    *   **Implementation Sketch:**
        1.  Query `DataAccess` for the most recent `StateSnapshot` event for the PID *before or at* `at_timestamp`.
        2.  If no snapshot, error.
        3.  If snapshot found, retrieve its state.
        4.  Query `DataAccess` for all `StateChange` events for the PID *between* the snapshot's timestamp and `at_timestamp`, ordered chronologically.
        5.  Iteratively apply the `new_state` from each `StateChange` event to the snapshot's state to arrive at the state for `at_timestamp`.
        *(This is a simplified version; real state reconstruction needs to handle the specifics of how state changes are captured and represented in events).*
    *   **Example:**
        ```iex
        # Get the state of PaymentProcessor just before a critical event occurred at `problem_ts`
        QueryCoordinator.reconstruct_genserver_state(payment_processor_pid, problem_ts - 1)
        ```

*   **`ElixirScope.Storage.QueryCoordinator.get_message_exchange(pid1, pid2, opts \\ []) :: {:ok, [ElixirScope.Events.t()]} | {:error, term()}`**
    *   **Purpose:** Show all messages sent between `pid1` and `pid2`.
    *   **`opts`:** `limit`, `since`, `until`.
    *   **Implementation:**
        1.  Query `DataAccess` for all `MessageSend` events where `sender_pid` is `pid1` and `receiver_pid` is `pid2`.
        2.  Query `DataAccess` for all `MessageSend` events where `sender_pid` is `pid2` and `receiver_pid` is `pid1`.
        3.  Query `DataAccess` for corresponding `MessageReceive` events based on `message_id` if available, or by matching (sender, receiver, timestamp proximity).
        4.  Merge and sort these events by timestamp.
    *   **Example:** `QueryCoordinator.get_message_exchange(order_receiver_pid, inventory_checker_pid)`

#### **Module: `ElixirScope.IExHelpers` (Wraps `QueryCoordinator`)**

This module would make the `QueryCoordinator` functions more pleasant to use from IEx, adding formatting.

*   **`ElixirScope.IExHelpers.history(target, opts \\ [])`**
    *   Calls `QueryCoordinator.get_process_events/2`.
    *   Formats and prints a summary of each event.
    *   Example Output:
        ```
        MiniProcessFlow.OrderReceiver <0.234.0> at <ts1>
          CALL handle_call({:new_order, %{...}}, {#PID<...>, #Ref<..._from>}, %{orders: %{}, next_id: 1})
            STATE (before): %{orders: %{}, next_id: 1}
            ... (messages sent from within this call) ...
            STATE (after): %{orders: %{1 => ...}, next_id: 2}
          EXIT :ok, new_state_map (duration: 1234Âµs)
        ```

*   **`ElixirScope.IExHelpers.state_at(target, timestamp_or_event_id)`**
    *   Calls `QueryCoordinator.reconstruct_genserver_state/2` (if timestamp) or finds the state from a specific `StateChange` or `FunctionExit` event.
    *   Pretty-prints the state.

*   **`ElixirScope.IExHelpers.messages(pid1, pid2_or_opts, opts_if_pid2_given \\ [])`**
    *   Calls `QueryCoordinator.get_message_exchange/3` or `QueryCoordinator.get_process_events/2` (filtered for messages).
    *   Formats and prints messages.

*   **`ElixirScope.IExHelpers.trace_flow(correlation_id_or_event_id)`**
    *   Calls `QueryCoordinator.get_correlated_trace/2`.
    *   Attempts to print a more structured flow, perhaps indenting nested calls.

---

### 5. APIs for AI Engine Interaction (During Runtime Analysis - Future)

While MiniProcessFlow is for *early development debugging*, the APIs that a future *runtime AI analysis engine* would use are built upon the same `QueryCoordinator` foundations. The AI engine would perform more complex queries:

*   Fetch large batches of events for pattern detection.
*   Query for specific sequences of events (e.g., "show me all GenServer calls that were not followed by a reply within X ms").
*   Request process interaction graphs (who called whom, who sent messages to whom).
*   Subscribe to live event streams for real-time anomaly detection (future `QueryCoordinator` capability).

---

### Summary of API Value for MiniProcessFlow Debugging:

1.  **Setup (`ElixirScope.start`)**: Easily activate ElixirScope with an OTP-focused tracing strategy. The AI generates a baseline runtime plan.
2.  **Dynamic Control (`ElixirScope.Runtime.trace/2`, `.stop_trace/1`)**: If the default AI plan isn't catching enough detail for a specific GenServer (e.g., `InventoryChecker` when a specific item is problematic), the developer can instantly increase trace detail for that PID or MFA *from IEx without recompiling MiniProcessFlow*.
    ```iex
    # MiniProcessFlow is running, I suspect InventoryChecker is misbehaving for "itemX"
    inventory_pid = Process.whereis(MiniProcessFlow.InventoryChecker)
    {:ok, _ref} = ElixirScope.Runtime.trace(inventory_pid, level: :full, capture: [:state_before, :state_after, :state_diff])
    # Now I trigger an order with "itemX"
    # ...
    ElixirScope.IExHelpers.history(inventory_pid, limit: 10) # See detailed trace
    ```
3.  **Data Inspection (`ElixirScope.IExHelpers`)**: After the problematic interaction occurs, use IEx helpers to:
    *   See the exact sequence of callbacks, arguments, return values, and state transitions for the misbehaving GenServer.
    *   Understand which messages were sent/received.
    *   Reconstruct the state of a GenServer at a point just before an error.
    *   Follow a single order's `correlation_id` across all involved GenServers.

This API set provides a powerful, dynamic, and introspective debugging experience that directly addresses the goal of making it easier to debug typical Elixir concurrent applications like MiniProcessFlow, forming a solid foundation for the visual "Execution Cinema."