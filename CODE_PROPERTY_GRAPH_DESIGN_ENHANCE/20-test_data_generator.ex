defmodule ElixirScope.ASTRepository.TestDataGenerator do
  @moduledoc """
  Provides utility functions for generating Elixir ASTs, mock module/function
  data, and other test fixtures needed for testing the AST Repository components.
  """

  alias ElixirScope.ASTRepository.{
    EnhancedModuleData,
    EnhancedFunctionData,
    VariableData,
    ComplexityMetrics,
    NodeIdentifier # For assigning AST Node IDs to generated ASTs
  }

  # --- Basic AST Snippet Generators ---

  @doc "Generates a simple assignment AST: `var = value_ast`"
  def simple_assignment_ast(var_name, value_ast, meta \\ [line: 1]) do
    quote do
      unquote({var_name, meta, nil}) = unquote(value_ast)
    end
  end

  @doc "Generates an if-else AST: `if condition, do: then_block, else: else_block`"
  def if_else_ast(condition_ast, then_block_ast, else_block_ast, meta \\ [line: 1]) do
    quote meta: meta do
      if unquote(condition_ast) do
        unquote(then_block_ast)
      else
        unquote(else_block_ast)
      end
    end
  end

  @doc "Generates a case statement AST."
  def case_ast(match_on_ast, clauses_asts, meta \\ [line: 1]) when is_list(clauses_asts) do
    # clauses_asts should be a list of {:->, clause_meta, [pattern_ast, body_ast]}
    quote meta: meta do
      case unquote(match_on_ast) do
        unquote_splicing(clauses_asts)
      end
    end
  end

  @doc "Generates a simple function call AST: `Mod.fun(arg1, arg2)` or `fun(arg1)`"
  def function_call_ast(module_ast_or_nil, fun_name, args_asts, meta \\ [line: 1]) do
    if module_ast_or_nil do
      quote meta: meta do
        unquote(module_ast_or_nil).unquote(fun_name)(unquote_splicing(args_asts))
      end
    else
      quote meta: meta do
        unquote(fun_name)(unquote_splicing(args_asts))
      end
    end
  end

  @doc "Generates a block of expressions."
  def block_ast(expr_asts, meta \\ []) do
    {:__block__, meta, expr_asts}
  end

  # --- Function and Module AST Generators ---

  @doc """
  Generates a complete function definition AST.
  `head_ast` is the function head, e.g., `quote(do: my_fun(a,b) when a > 0)`.
  `body_ast` is the function body, e.g., `quote(do: a + b)`.
  """
  @spec function_def_ast(
          type :: :def | :defp | :defmacro | :defmacrop,
          head_ast :: Macro.t(),
          body_ast :: Macro.t(),
          meta :: keyword()
        ) :: Macro.t()
  def function_def_ast(type, head_ast, body_ast, meta \\ [line: 1]) do
    # Ensure head_ast is in the form expected by def, e.g., {name, meta, args}
    # Body needs to be wrapped in `[do: actual_body]` for def.
    formatted_body = if elem(body_ast, 0) == :__block__, do: body_ast, else: block_ast([body_ast])
    {type, meta, [head_ast, [do: formatted_body]]}
  end

  def simple_function_head_ast(fun_name, params \\ [], guard_ast \\ nil, meta \\ []) do
    # params are atoms like :a, :b or patterns
    param_asts = Enum.map(List.wrap(params), fn
      p when is_atom(p) -> {p, [line: (meta[:line] || 1)], nil}
      p_ast -> p_ast # Assume already quoted pattern
    end)

    head = {fun_name, [line: (meta[:line] || 1), context: Elixir] ++ meta, param_asts} # context: Elixir for func name
    if guard_ast do
      # The structure for a head with a guard is {{name, meta, args}, [when: guard_expr]}
      # This is tricky as the guard is part of the clause list for `def`.
      # Let's return a tuple that function_def_ast can interpret or adjust function_def_ast.
      # For now, let's assume `head_ast` in `function_def_ast` can be `{{name,meta,args}, [when: guard]}`
      {head, [when: guard_ast]}
    else
      head
    end
  end


  @doc """
  Generates a complete module definition AST.
  `function_defs_asts` is a list of ASTs generated by `function_def_ast`.
  """
  @spec module_def_ast(
          module_name_alias :: Macro.t(), # e.g., quote(do: MyApp.MyModule)
          body_asts :: [Macro.t()], # Function defs, attributes, etc.
          meta :: keyword()
        ) :: Macro.t()
  def module_def_ast(module_name_alias, body_asts, meta \\ [line: 1]) do
    {:defmodule, meta, [module_name_alias, [do: block_ast(body_asts)]]}
  end

  def simple_module_name_alias(module_name_atom) do
    # MyApp.MyModule -> {:__aliases__, [], [:MyApp, :MyModule]}
    parts = Module.split(module_name_atom)
    {:__aliases__, [alias: false], parts}
  end

  # --- Generating EnhancedData Structs with AST Node IDs ---

  @doc """
  Generates an `EnhancedFunctionData` struct from a function AST,
  assigning AST Node IDs and performing basic analysis.
  """
  @spec generate_enhanced_function_data(
          module_name :: atom(),
          function_ast :: Macro.t(), # A single def/defp AST
          file_path :: String.t(),
          opts :: keyword()
        ) :: {:ok, EnhancedFunctionData.t()} | {:error, term()}
  def generate_enhanced_function_data(module_name, function_ast, file_path \\ "test_gen.ex", opts \\ []) do
    {type, _meta, [{fun_name_ast, _, params_ast_list} | _]} = function_ast
    fun_name = if is_atom(fun_name_ast), do: fun_name_ast, else: elem(fun_name_ast, 0) # for {name, meta, args}
    arity = length(params_ast_list)
    clause_index = Keyword.get(opts, :clause_index, 0) # For multi-clause functions

    # 1. Assign AST Node IDs
    id_manager_context = NodeIdentifier.initial_context_for_function(module_name, fun_name, arity, clause_index)
    ast_with_ids = NodeIdentifier.assign_ids_custom_traverse(function_ast, id_manager_context) # Using custom for path

    # 2. Perform analysis (using ASTAnalyzer)
    # ASTAnalyzer.analyze_function_ast expects the raw AST and other params.
    # We pass the AST with IDs to ensure downstream components can find them if needed,
    # but ASTAnalyzer might re-assign or use its own traversal.
    # For test data, we might want to control this more directly or mock ASTAnalyzer.

    # For this generator, let's create a basic EnhancedFunctionData and fill essentials.
    # A full analysis would be done by ASTAnalyzer in a real flow.
    func_meta = ElixirScope.ASTRepository.ASTAnalyzer.get_function_meta(ast_with_ids)
    head_ast = ElixirScope.ASTRepository.ASTAnalyzer.get_function_head(ast_with_ids)
    body_ast = ElixirScope.ASTRepository.ASTAnalyzer.get_function_body(ast_with_ids)

    # Basic complexity for test data
    complexity_metrics = %ComplexityMetrics{
      cyclomatic_complexity: ElixirScope.ASTRepository.ASTAnalyzer.count_ast_decision_points(ast_with_ids) + 1,
      nesting_depth: ElixirScope.ASTRepository.ASTAnalyzer.calculate_ast_nesting(ast_with_ids)
      # Fill other metrics with defaults or calculate simply
    }

    efd = %EnhancedFunctionData{
      module_name: module_name,
      function_name: fun_name,
      arity: arity,
      ast_node_id: NodeIdentifier.get_id_from_ast_meta(func_meta) || "def_#{fun_name}_#{arity}", # ID of the def itself
      file_path: file_path,
      line_start: Keyword.get(func_meta, :line, 1),
      line_end: Keyword.get(func_meta, :line, 1) + (Macro.to_string(ast_with_ids) |> String.split("\n") |> length() |> Kernel.-(1)),
      ast: ast_with_ids,
      head_ast: head_ast,
      body_ast: body_ast,
      visibility: if(type == :defp, do: :private, else: :public),
      complexity_metrics: complexity_metrics, # Add field to EFD if not there or use main complexity score
      cyclomatic_complexity: complexity_metrics.cyclomatic_complexity, # if separate
      nesting_depth: complexity_metrics.nesting_depth, # if separate
      # Initialize other fields to defaults
      is_macro: type in [:defmacro, :defmacrop],
      is_guard: false, is_callback: false, is_delegate: false,
      clauses: [], guard_clauses: ElixirScope.ASTRepository.ASTAnalyzer.extract_guards_from_clauses(ast_with_ids),
      pattern_matches: [], parameters: [], local_variables: [], captures: [],
      variable_mutations: [], return_points: [], called_functions: [], calling_functions: [], external_calls: [],
      complexity_score: 0.0, maintainability_index: 0.0, test_coverage: nil, performance_profile: nil,
      doc_string: nil, spec: nil, examples: [], tags: [], annotations: %{}, metadata: %{}
    }
    {:ok, efd}
  end


  @doc """
  Generates an `EnhancedModuleData` struct from a module AST.
  """
  @spec generate_enhanced_module_data(
          module_ast_with_ids :: Macro.t(), # Assumes IDs are already assigned
          module_name :: atom(),
          file_path :: String.t(),
          opts :: keyword()
        ) :: {:ok, EnhancedModuleData.t()} | {:error, term()}
  def generate_enhanced_module_data(module_ast_with_ids, module_name, file_path, opts \\ []) do
    # This would typically call ASTAnalyzer.analyze_module_ast
    # For test data generation, we can mock parts of it.
    # Let's assume module_ast_with_ids already has Node IDs.
    # We still need to extract functions and analyze them.

    functions_data = module_ast_with_ids
    |> ElixirScope.ASTRepository.ASTAnalyzer.get_module_body() # Helper assumed from ASTAnalyzer
    |> Enum.filter(fn node -> match?({:def, _, _}, node) or match?({:defp, _, _}, node) end) # Basic filter for def/defp
    |> Enum.map(fn fun_ast ->
      case generate_enhanced_function_data(module_name, fun_ast, file_path, Keyword.merge(opts, [clause_index: 0])) do # Add clause_index if needed
        {:ok, efd} -> efd
        _ -> nil # Skip on error for test data
      end
    end)
    |> Enum.reject(&is_nil/1)

    emd = %EnhancedModuleData{
      module_name: module_name,
      file_path: file_path,
      file_hash: :crypto.hash(:sha256, Macro.to_string(module_ast_with_ids)) |> Base.encode16(),
      ast: module_ast_with_ids,
      ast_size: ElixirScope.ASTRepository.ASTAnalyzer.count_ast_nodes(module_ast_with_ids),
      ast_depth: ElixirScope.ASTRepository.ASTAnalyzer.calculate_ast_depth(module_ast_with_ids),
      functions: functions_data,
      # Fill other fields with defaults or basic extractions
      macros: [], module_attributes: %{}, typespecs: [],
      imports: [], aliases: [], requires: [], uses: [], behaviours: [],
      callbacks_implemented: [], child_specs: [],
      complexity_metrics: %ComplexityMetrics{cyclomatic_complexity: 1 + Enum.sum(Enum.map(functions_data, & &1.cyclomatic_complexity))},
      code_smells: [], security_risks: [],
      last_modified: DateTime.utc_now(), last_analyzed: DateTime.utc_now(), metadata: %{}
    }
    {:ok, emd}
  end


  # --- Complex Scenario Generators ---

  @doc """
  Generates a module with multiple functions, including various constructs.
  """
  def generate_complex_test_module_ast(module_name_atom, num_functions \\ 3) do
    fun_prefix = "func_for_#{module_name_atom}"

    functions = Enum.map(1..num_functions, fn i ->
      params = Enum.map(1..(rem(i,3)+1), &String.to_atom("p_#{&1}"))
      head = simple_function_head_ast(String.to_atom("#{fun_prefix}_#{i}"), params, nil, line: i*10)

      body_exprs = [
        simple_assignment_ast(:x, quote(do: unquote(List.first(params) || 0) + unquote(i))),
        if_else_ast(
          quote(do: x > unquote(i*5)),
          block_ast([function_call_ast(nil, :handle_greater, [quote(do: x)])]),
          block_ast([function_call_ast(nil, :handle_smaller, [quote(do: x)])])
        )
      ]
      body = block_ast(body_exprs)
      function_def_ast(:def, head, body, line: i*10)
    end)

    # Add a GenServer-like function for pattern matching tests
    gs_callbacks = [
      function_def_ast(:def,
        simple_function_head_ast(:handle_call, [:message, :from, :state]),
        block_ast([quote(do: {:reply, :ok, state})]),
        line: (num_functions+1)*10
      ),
      function_def_ast(:def,
        simple_function_head_ast(:init, [:args]),
        block_ast([quote(do: {:ok, %{data: args}})]),
        line: (num_functions+2)*10
      )
    ]

    module_name_alias = simple_module_name_alias(module_name_atom)
    module_def_ast(module_name_alias, functions ++ gs_callbacks)
  end


  @doc """
  Generates a mock project structure on disk for ProjectPopulator tests.
  Returns the root path of the created project.
  """
  def create_mock_project_on_disk(project_name_atom, num_modules \\ 2, num_functions_per_module \\ 2) do
    root_path = Path.join(["tmp", "test_projects", Atom.to_string(project_name_atom)])
    lib_path = Path.join(root_path, "lib")
    File.mkdir_p!(lib_path)

    Enum.each(1..num_modules, fn i ->
      module_name_atom = Module.concat([project_name_atom, String.to_atom("Module#{i}")])
      module_ast = generate_complex_test_module_ast(module_name_atom, num_functions_per_module)
      module_code = Macro.to_string(module_ast)

      # Determine file path based on module name
      module_parts = Module.split(module_name_atom) |> Enum.map(&Macro.underscore/1)
      relative_file_path = Path.join(module_parts) <> ".ex"
      file_path = Path.join(lib_path, relative_file_path)

      File.mkdir_p!(Path.dirname(file_path))
      File.write!(file_path, module_code)
    end)
    root_path
  end

end
